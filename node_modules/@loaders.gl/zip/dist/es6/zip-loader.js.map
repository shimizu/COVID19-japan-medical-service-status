{"version":3,"sources":["../../src/zip-loader.js"],"names":["JSZip","VERSION","ZipLoader","id","name","version","extensions","mimeType","category","test","parse","parseZipAsync","data","options","promises","fileMap","jsZip","zip","loadAsync","forEach","relativePath","zipEntry","subFilename","promise","loadZipEntry","then","arrayBufferOrError","push","Promise","all","error","log","arrayBuffer","file","async","dataType"],"mappings":"AAEA,OAAOA,KAAP,MAAkB,OAAlB;AAGA,MAAMC,OAAO,GAAG,mBAAuB,WAAvB,aAAmD,QAAnE;AAEA,OAAO,MAAMC,SAAS,GAAG;AACvBC,EAAAA,EAAE,EAAE,KADmB;AAEvBC,EAAAA,IAAI,EAAE,aAFiB;AAGvBC,EAAAA,OAAO,EAAEJ,OAHc;AAIvBK,EAAAA,UAAU,EAAE,CAAC,KAAD,CAJW;AAKvBC,EAAAA,QAAQ,EAAE,iBALa;AAMvBC,EAAAA,QAAQ,EAAE,SANa;AAOvBC,EAAAA,IAAI,EAAE,IAPiB;AAQvBC,EAAAA,KAAK,EAAEC;AARgB,CAAlB;;AAYP,eAAeA,aAAf,CAA6BC,IAA7B,EAAmCC,OAAnC,EAA4C;AAC1C,QAAMC,QAAQ,GAAG,EAAjB;AACA,QAAMC,OAAO,GAAG,EAAhB;;AAEA,MAAI;AACF,UAAMC,KAAK,GAAG,IAAIhB,KAAJ,EAAd;AAEA,UAAMiB,GAAG,GAAG,MAAMD,KAAK,CAACE,SAAN,CAAgBN,IAAhB,EAAsBC,OAAtB,CAAlB;AAGAI,IAAAA,GAAG,CAACE,OAAJ,CAAY,CAACC,YAAD,EAAeC,QAAf,KAA4B;AACtC,YAAMC,WAAW,GAAGD,QAAQ,CAACjB,IAA7B;AAEA,YAAMmB,OAAO,GAAGC,YAAY,CAACR,KAAD,EAAQM,WAAR,EAAqBT,OAArB,CAAZ,CAA0CY,IAA1C,CAA+CC,kBAAkB,IAAI;AACnFX,QAAAA,OAAO,CAACK,YAAD,CAAP,GAAwBM,kBAAxB;AACD,OAFe,CAAhB;AAKAZ,MAAAA,QAAQ,CAACa,IAAT,CAAcJ,OAAd;AACD,KATD;AAWA,UAAMK,OAAO,CAACC,GAAR,CAAYf,QAAZ,CAAN;AACA,WAAOC,OAAP;AACD,GAnBD,CAmBE,OAAOe,KAAP,EAAc;AACdjB,IAAAA,OAAO,CAACkB,GAAR,CAAYD,KAAZ,uCAAiDA,KAAjD;AACA,UAAMA,KAAN;AACD;AACF;;AAED,eAAeN,YAAf,CAA4BR,KAA5B,EAAmCM,WAAnC,EAAgDT,OAAhD,EAAyD;AAGvD,MAAI;AACF,UAAMmB,WAAW,GAAG,MAAMhB,KAAK,CAACiB,IAAN,CAAWX,WAAX,EAAwBY,KAAxB,CAA8BrB,OAAO,CAACsB,QAAR,IAAoB,aAAlD,CAA1B;AACA,WAAOH,WAAP;AACD,GAHD,CAGE,OAAOF,KAAP,EAAc;AACdjB,IAAAA,OAAO,CAACkB,GAAR,CAAYD,KAAZ,0BAAoCR,WAApC,gCAAqEQ,KAArE;AAEA,WAAOA,KAAP;AACD;AACF","sourcesContent":["// __VERSION__ is injected by babel-plugin-version-inline\n/* global __VERSION__ */\nimport JSZip from 'jszip';\n\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport const ZipLoader = {\n  id: 'zip',\n  name: 'Zip Archive',\n  version: VERSION,\n  extensions: ['zip'],\n  mimeType: 'application/zip',\n  category: 'archive',\n  test: 'PK',\n  parse: parseZipAsync\n};\n\n// TODO - Could return a map of promises, perhaps as an option...\nasync function parseZipAsync(data, options) {\n  const promises = [];\n  const fileMap = {};\n\n  try {\n    const jsZip = new JSZip();\n\n    const zip = await jsZip.loadAsync(data, options);\n\n    // start to load each file in this zip\n    zip.forEach((relativePath, zipEntry) => {\n      const subFilename = zipEntry.name;\n\n      const promise = loadZipEntry(jsZip, subFilename, options).then(arrayBufferOrError => {\n        fileMap[relativePath] = arrayBufferOrError;\n      });\n\n      // Ensure Promise.all doesn't ignore rejected promises.\n      promises.push(promise);\n    });\n\n    await Promise.all(promises);\n    return fileMap;\n  } catch (error) {\n    options.log.error(`Unable to read zip archive: ${error}`);\n    throw error;\n  }\n}\n\nasync function loadZipEntry(jsZip, subFilename, options) {\n  // jszip supports both arraybuffer and text, the main loaders.gl types\n  // https://stuk.github.io/jszip/documentation/api_zipobject/async.html\n  try {\n    const arrayBuffer = await jsZip.file(subFilename).async(options.dataType || 'arraybuffer');\n    return arrayBuffer;\n  } catch (error) {\n    options.log.error(`Unable to read ${subFilename} from zip archive: ${error}`);\n    // Store error in place of data in map\n    return error;\n  }\n}\n"],"file":"zip-loader.js"}