import JSZip from 'jszip';
const VERSION = typeof "2.1.6" !== 'undefined' ? "2.1.6" : 'latest';
export const ZipLoader = {
  id: 'zip',
  name: 'Zip Archive',
  version: VERSION,
  extensions: ['zip'],
  mimeType: 'application/zip',
  category: 'archive',
  test: 'PK',
  parse: parseZipAsync
};

async function parseZipAsync(data, options) {
  const promises = [];
  const fileMap = {};

  try {
    const jsZip = new JSZip();
    const zip = await jsZip.loadAsync(data, options);
    zip.forEach((relativePath, zipEntry) => {
      const subFilename = zipEntry.name;
      const promise = loadZipEntry(jsZip, subFilename, options).then(arrayBufferOrError => {
        fileMap[relativePath] = arrayBufferOrError;
      });
      promises.push(promise);
    });
    await Promise.all(promises);
    return fileMap;
  } catch (error) {
    options.log.error("Unable to read zip archive: ".concat(error));
    throw error;
  }
}

async function loadZipEntry(jsZip, subFilename, options) {
  try {
    const arrayBuffer = await jsZip.file(subFilename).async(options.dataType || 'arraybuffer');
    return arrayBuffer;
  } catch (error) {
    options.log.error("Unable to read ".concat(subFilename, " from zip archive: ").concat(error));
    return error;
  }
}
//# sourceMappingURL=zip-loader.js.map