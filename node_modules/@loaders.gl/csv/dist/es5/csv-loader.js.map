{"version":3,"sources":["../../src/csv-loader.js"],"names":["VERSION","CSVLoader","id","name","version","extensions","mimeType","category","parse","arrayBuffer","options","parseCSVSync","TextDecoder","decode","parseTextSync","parseInBatches","parseCSVInBatches","testText","csv","TableBatch","RowTableBatch","batchSize","csvText","config","header","hasHeader","dynamicTyping","download","error","e","Error","result","Papa","data","asyncIterator","TableBatchType","asyncQueue","AsyncQueue","isFirstRow","headerRow","tableBatchBuilder","schema","step","results","parser","row","undefined","isHeaderRow","deduceSchema","TableBatchBuilder","addRow","isFull","enqueue","getNormalizedBatch","complete","file","batch","close","AsyncIteratorStreamer","every","value","abort","i","length","columnName","String","index","type","Float32Array","Array"],"mappings":";;;;;;;;;;;;;;;;;AAGA;;AACA;;AACA;;;;;;AAGA,IAAMA,OAAO,GAAG,mBAAuB,WAAvB,aAAmD,QAAnE;AAEA,IAAMC,SAAS,GAAG;AAChBC,EAAAA,EAAE,EAAE,KADY;AAEhBC,EAAAA,IAAI,EAAE,KAFU;AAGhBC,EAAAA,OAAO,EAAEJ,OAHO;AAIhBK,EAAAA,UAAU,EAAE,CAAC,KAAD,CAJI;AAKhBC,EAAAA,QAAQ,EAAE,UALM;AAMhBC,EAAAA,QAAQ,EAAE,OANM;AAOhBC,EAAAA,KAAK;AAAA,iFAAE,iBAAOC,WAAP,EAAoBC,OAApB;AAAA;AAAA;AAAA;AAAA;AAAA,+CACLC,YAAY,CAAC,IAAIC,WAAJ,GAAkBC,MAAlB,CAAyBJ,WAAzB,CAAD,EAAwCC,OAAxC,CADP;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,KAPW;AAShBI,EAAAA,aAAa,EAAEH,YATC;AAUhBI,EAAAA,cAAc,EAAEC,iBAVA;AAWhBC,EAAAA,QAAQ,EAAE,IAXM;AAYhBP,EAAAA,OAAO,EAAE;AACPQ,IAAAA,GAAG,EAAE;AACHC,MAAAA,UAAU,EAAEC,qBADT;AAEHC,MAAAA,SAAS,EAAE;AAFR;AADE;AAZO,CAAlB;eAoBepB,S;;;AAEf,SAASU,YAAT,CAAsBW,OAAtB,EAA+BZ,OAA/B,EAAwC;AAEtCA,EAAAA,OAAO,qBAAOT,SAAS,CAACS,OAAjB,MAA6BA,OAA7B,CAAP;AACAA,EAAAA,OAAO,CAACQ,GAAR,qBAAkBjB,SAAS,CAACS,OAAV,CAAkBQ,GAApC,MAA4CR,OAAO,CAACQ,GAApD;;AAEA,MAAMK,MAAM;AACVC,IAAAA,MAAM,EAAEC,SAAS,CAACH,OAAD,EAAUZ,OAAV,CADP;AAEVgB,IAAAA,aAAa,EAAE;AAFL,KAGPhB,OAAO,CAACQ,GAHD;AAIVS,IAAAA,QAAQ,EAAE,KAJA;AAKVC,IAAAA,KAAK,EAAE,eAAAC,CAAC,EAAI;AACV,YAAM,IAAIC,KAAJ,CAAUD,CAAV,CAAN;AACD;AAPS,IAAZ;;AAUA,MAAME,MAAM,GAAGC,sBAAKxB,KAAL,CAAWc,OAAX,EAAoBC,MAApB,CAAf;;AACA,SAAOQ,MAAM,CAACE,IAAd;AACD;;AAGD,SAASjB,iBAAT,CAA2BkB,aAA3B,EAA0CxB,OAA1C,EAAmD;AAEjDA,EAAAA,OAAO,qBAAOT,SAAS,CAACS,OAAjB,MAA6BA,OAA7B,CAAP;AACAA,EAAAA,OAAO,CAACQ,GAAR,qBAAkBjB,SAAS,CAACS,OAAV,CAAkBQ,GAApC,MAA4CR,OAAO,CAACQ,GAApD;AAHiD,MAK1CG,SAL0C,GAK7BX,OAAO,CAACQ,GALqB,CAK1CG,SAL0C;AAMjD,MAAMc,cAAc,GAAGzB,OAAO,CAACQ,GAAR,CAAYC,UAAnC;AAEA,MAAMiB,UAAU,GAAG,IAAIC,kBAAJ,EAAnB;AAEA,MAAIC,UAAU,GAAG,IAAjB;AACA,MAAIC,SAAS,GAAG,IAAhB;AACA,MAAIC,iBAAiB,GAAG,IAAxB;AACA,MAAIC,MAAM,GAAG,IAAb;AAEA,MAAMlB,MAAM,GAAG;AACbI,IAAAA,QAAQ,EAAE,KADG;AAEbD,IAAAA,aAAa,EAAE,IAFF;AAGbF,IAAAA,MAAM,EAAE,KAHK;AAYbkB,IAAAA,IAZa,gBAYRC,OAZQ,EAYCC,MAZD,EAYS;AACpB,UAAMC,GAAG,GAAGF,OAAO,CAACV,IAApB;;AAGA,UAAIK,UAAU,IAAI,CAACC,SAAnB,EAA8B;AAC5B,YAAMf,MAAM,GAAGd,OAAO,CAACc,MAAR,KAAmBsB,SAAnB,GAA+BC,WAAW,CAACF,GAAD,CAA1C,GAAkDnC,OAAO,CAACc,MAAzE;;AACA,YAAIA,MAAJ,EAAY;AACVe,UAAAA,SAAS,GAAGM,GAAZ;AACA;AACD;AACF;;AAGD,UAAIP,UAAJ,EAAgB;AACdA,QAAAA,UAAU,GAAG,KAAb;AACAG,QAAAA,MAAM,GAAGO,YAAY,CAACH,GAAD,EAAMN,SAAN,CAArB;AACD;;AAGDC,MAAAA,iBAAiB,GACfA,iBAAiB,IAAI,IAAIS,yBAAJ,CAAsBd,cAAtB,EAAsCM,MAAtC,EAA8CpB,SAA9C,CADvB;AAGAmB,MAAAA,iBAAiB,CAACU,MAAlB,CAAyBL,GAAzB;;AAEA,UAAIL,iBAAiB,CAACW,MAAlB,EAAJ,EAAgC;AAC9Bf,QAAAA,UAAU,CAACgB,OAAX,CAAmBZ,iBAAiB,CAACa,kBAAlB,EAAnB;AACD;AACF,KAvCY;AA0CbC,IAAAA,QA1Ca,oBA0CJX,OA1CI,EA0CKY,IA1CL,EA0CW;AAEtB,UAAMC,KAAK,GAAGhB,iBAAiB,CAACa,kBAAlB,EAAd;;AACA,UAAIG,KAAJ,EAAW;AACTpB,QAAAA,UAAU,CAACgB,OAAX,CAAmBI,KAAnB;AACD;;AACDpB,MAAAA,UAAU,CAACqB,KAAX;AACD;AAjDY,GAAf;;AAoDAzB,wBAAKxB,KAAL,CAAW0B,aAAX,EAA0BX,MAA1B,EAAkCmC,iCAAlC;;AAIA,SAAOtB,UAAP;AACD;;AAED,SAASW,WAAT,CAAqBF,GAArB,EAA0B;AACxB,SAAOA,GAAG,CAACc,KAAJ,CAAU,UAAAC,KAAK;AAAA,WAAI,OAAOA,KAAP,KAAiB,QAArB;AAAA,GAAf,CAAP;AACD;;AAED,SAASnC,SAAT,CAAmBH,OAAnB,EAA4BZ,OAA5B,EAAqC;AACnC,MAAI,YAAYA,OAAhB,EAAyB;AACvB,WAAOA,OAAO,CAACc,MAAf;AACD;;AAED,MAAIA,MAAM,GAAG,KAAb;;AACAQ,wBAAKxB,KAAL,CAAWc,OAAX,EAAoB;AAClBK,IAAAA,QAAQ,EAAE,KADQ;AAElBD,IAAAA,aAAa,EAAE,IAFG;AAGlBgB,IAAAA,IAAI,EAAE,cAACC,OAAD,EAAUC,MAAV,EAAqB;AACzB,UAAMC,GAAG,GAAGF,OAAO,CAACV,IAApB;AACAT,MAAAA,MAAM,GAAGuB,WAAW,CAACF,GAAD,CAApB;AACAD,MAAAA,MAAM,CAACiB,KAAP;AACD;AAPiB,GAApB;;AAUA,SAAOrC,MAAP;AACD;;AAED,SAASwB,YAAT,CAAsBH,GAAtB,EAA2BN,SAA3B,EAAsC;AACpC,MAAME,MAAM,GAAGF,SAAS,GAAG,EAAH,GAAQ,EAAhC;;AACA,OAAK,IAAIuB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjB,GAAG,CAACkB,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;AACnC,QAAME,UAAU,GAAIzB,SAAS,IAAIA,SAAS,CAACuB,CAAD,CAAvB,IAA+BA,CAAlD;AACA,QAAMF,KAAK,GAAGf,GAAG,CAACiB,CAAD,CAAjB;;AACA,qCAAeF,KAAf;AACE,WAAK,QAAL;AACA,WAAK,SAAL;AAEEnB,QAAAA,MAAM,CAACuB,UAAD,CAAN,GAAqB;AAAC7D,UAAAA,IAAI,EAAE8D,MAAM,CAACD,UAAD,CAAb;AAA2BE,UAAAA,KAAK,EAAEJ,CAAlC;AAAqCK,UAAAA,IAAI,EAAEC;AAA3C,SAArB;AACA;;AACF,WAAK,QAAL;AACA;AACE3B,QAAAA,MAAM,CAACuB,UAAD,CAAN,GAAqB;AAAC7D,UAAAA,IAAI,EAAE8D,MAAM,CAACD,UAAD,CAAb;AAA2BE,UAAAA,KAAK,EAAEJ,CAAlC;AAAqCK,UAAAA,IAAI,EAAEE;AAA3C,SAArB;AARJ;AAYD;;AACD,SAAO5B,MAAP;AACD","sourcesContent":["// __VERSION__ is injected by babel-plugin-version-inline\n/* global __VERSION__ */\n/* global TextDecoder */\nimport {AsyncQueue, TableBatchBuilder, RowTableBatch} from '@loaders.gl/tables';\nimport Papa from './libs/papaparse';\nimport AsyncIteratorStreamer from './lib/async-iterator-streamer';\n\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nconst CSVLoader = {\n  id: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv'],\n  mimeType: 'text/csv',\n  category: 'table',\n  parse: async (arrayBuffer, options) =>\n    parseCSVSync(new TextDecoder().decode(arrayBuffer), options),\n  parseTextSync: parseCSVSync,\n  parseInBatches: parseCSVInBatches,\n  testText: null,\n  options: {\n    csv: {\n      TableBatch: RowTableBatch,\n      batchSize: 10\n    }\n  }\n};\n\nexport default CSVLoader;\n\nfunction parseCSVSync(csvText, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...CSVLoader.options, ...options};\n  options.csv = {...CSVLoader.options.csv, ...options.csv};\n\n  const config = {\n    header: hasHeader(csvText, options),\n    dynamicTyping: true, // Convert numbers and boolean values in rows from strings\n    ...options.csv,\n    download: false, // We handle loading, no need for papaparse to do it for us\n    error: e => {\n      throw new Error(e);\n    }\n  };\n\n  const result = Papa.parse(csvText, config);\n  return result.data;\n}\n\n// TODO - support batch size 0 = no batching/single batch?\nfunction parseCSVInBatches(asyncIterator, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...CSVLoader.options, ...options};\n  options.csv = {...CSVLoader.options.csv, ...options.csv};\n\n  const {batchSize} = options.csv;\n  const TableBatchType = options.csv.TableBatch;\n\n  const asyncQueue = new AsyncQueue();\n\n  let isFirstRow = true;\n  let headerRow = null;\n  let tableBatchBuilder = null;\n  let schema = null;\n\n  const config = {\n    download: false, // We handle loading, no need for papaparse to do it for us\n    dynamicTyping: true, // Convert numbers and boolean values in rows from strings\n    header: false, // Unfortunately, header detection is not automatic and does not infer types\n\n    // chunk(results, parser) {\n    //   // TODO batch before adding to queue.\n    //   console.log('Chunk:', results, parser);\n    //   asyncQueue.enqueue(results.data);\n    // },\n\n    // step is called on every row\n    step(results, parser) {\n      const row = results.data;\n\n      // Check if we need to save a header row\n      if (isFirstRow && !headerRow) {\n        const header = options.header === undefined ? isHeaderRow(row) : options.header;\n        if (header) {\n          headerRow = row;\n          return;\n        }\n      }\n\n      // If first data row, we can deduce the schema\n      if (isFirstRow) {\n        isFirstRow = false;\n        schema = deduceSchema(row, headerRow);\n      }\n\n      // Add the row\n      tableBatchBuilder =\n        tableBatchBuilder || new TableBatchBuilder(TableBatchType, schema, batchSize);\n\n      tableBatchBuilder.addRow(row);\n      // If a batch has been completed, emit it\n      if (tableBatchBuilder.isFull()) {\n        asyncQueue.enqueue(tableBatchBuilder.getNormalizedBatch());\n      }\n    },\n\n    // complete is called when all rows have been read\n    complete(results, file) {\n      // Ensure any final (partial) batch gets emitted\n      const batch = tableBatchBuilder.getNormalizedBatch();\n      if (batch) {\n        asyncQueue.enqueue(batch);\n      }\n      asyncQueue.close();\n    }\n  };\n\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n\n  // TODO - Does it matter if we return asyncIterable or asyncIterator\n  // return asyncQueue[Symbol.asyncIterator]();\n  return asyncQueue;\n}\n\nfunction isHeaderRow(row) {\n  return row.every(value => typeof value === 'string');\n}\n\nfunction hasHeader(csvText, options) {\n  if ('header' in options) {\n    return options.header;\n  }\n\n  let header = false;\n  Papa.parse(csvText, {\n    download: false,\n    dynamicTyping: true,\n    step: (results, parser) => {\n      const row = results.data;\n      header = isHeaderRow(row);\n      parser.abort();\n    }\n  });\n\n  return header;\n}\n\nfunction deduceSchema(row, headerRow) {\n  const schema = headerRow ? {} : [];\n  for (let i = 0; i < row.length; i++) {\n    const columnName = (headerRow && headerRow[i]) || i;\n    const value = row[i];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n  }\n  return schema;\n}\n"],"file":"csv-loader.js"}