{"version":3,"sources":["../../src/csv-loader.js"],"names":["AsyncQueue","TableBatchBuilder","RowTableBatch","Papa","AsyncIteratorStreamer","VERSION","CSVLoader","id","name","version","extensions","mimeType","category","parse","arrayBuffer","options","parseCSVSync","TextDecoder","decode","parseTextSync","parseInBatches","parseCSVInBatches","testText","csv","TableBatch","batchSize","csvText","config","header","hasHeader","dynamicTyping","download","error","e","Error","result","data","asyncIterator","TableBatchType","asyncQueue","isFirstRow","headerRow","tableBatchBuilder","schema","step","results","parser","row","undefined","isHeaderRow","deduceSchema","addRow","isFull","enqueue","getNormalizedBatch","complete","file","batch","close","every","value","abort","i","length","columnName","String","index","type","Float32Array","Array"],"mappings":"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","sourcesContent":["// __VERSION__ is injected by babel-plugin-version-inline\n/* global __VERSION__ */\n/* global TextDecoder */\nimport {AsyncQueue, TableBatchBuilder, RowTableBatch} from '@loaders.gl/tables';\nimport Papa from './libs/papaparse';\nimport AsyncIteratorStreamer from './lib/async-iterator-streamer';\n\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nconst CSVLoader = {\n  id: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv'],\n  mimeType: 'text/csv',\n  category: 'table',\n  parse: async (arrayBuffer, options) =>\n    parseCSVSync(new TextDecoder().decode(arrayBuffer), options),\n  parseTextSync: parseCSVSync,\n  parseInBatches: parseCSVInBatches,\n  testText: null,\n  options: {\n    csv: {\n      TableBatch: RowTableBatch,\n      batchSize: 10\n    }\n  }\n};\n\nexport default CSVLoader;\n\nfunction parseCSVSync(csvText, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...CSVLoader.options, ...options};\n  options.csv = {...CSVLoader.options.csv, ...options.csv};\n\n  const config = {\n    header: hasHeader(csvText, options),\n    dynamicTyping: true, // Convert numbers and boolean values in rows from strings\n    ...options.csv,\n    download: false, // We handle loading, no need for papaparse to do it for us\n    error: e => {\n      throw new Error(e);\n    }\n  };\n\n  const result = Papa.parse(csvText, config);\n  return result.data;\n}\n\n// TODO - support batch size 0 = no batching/single batch?\nfunction parseCSVInBatches(asyncIterator, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...CSVLoader.options, ...options};\n  options.csv = {...CSVLoader.options.csv, ...options.csv};\n\n  const {batchSize} = options.csv;\n  const TableBatchType = options.csv.TableBatch;\n\n  const asyncQueue = new AsyncQueue();\n\n  let isFirstRow = true;\n  let headerRow = null;\n  let tableBatchBuilder = null;\n  let schema = null;\n\n  const config = {\n    download: false, // We handle loading, no need for papaparse to do it for us\n    dynamicTyping: true, // Convert numbers and boolean values in rows from strings\n    header: false, // Unfortunately, header detection is not automatic and does not infer types\n\n    // chunk(results, parser) {\n    //   // TODO batch before adding to queue.\n    //   console.log('Chunk:', results, parser);\n    //   asyncQueue.enqueue(results.data);\n    // },\n\n    // step is called on every row\n    step(results, parser) {\n      const row = results.data;\n\n      // Check if we need to save a header row\n      if (isFirstRow && !headerRow) {\n        const header = options.header === undefined ? isHeaderRow(row) : options.header;\n        if (header) {\n          headerRow = row;\n          return;\n        }\n      }\n\n      // If first data row, we can deduce the schema\n      if (isFirstRow) {\n        isFirstRow = false;\n        schema = deduceSchema(row, headerRow);\n      }\n\n      // Add the row\n      tableBatchBuilder =\n        tableBatchBuilder || new TableBatchBuilder(TableBatchType, schema, batchSize);\n\n      tableBatchBuilder.addRow(row);\n      // If a batch has been completed, emit it\n      if (tableBatchBuilder.isFull()) {\n        asyncQueue.enqueue(tableBatchBuilder.getNormalizedBatch());\n      }\n    },\n\n    // complete is called when all rows have been read\n    complete(results, file) {\n      // Ensure any final (partial) batch gets emitted\n      const batch = tableBatchBuilder.getNormalizedBatch();\n      if (batch) {\n        asyncQueue.enqueue(batch);\n      }\n      asyncQueue.close();\n    }\n  };\n\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n\n  // TODO - Does it matter if we return asyncIterable or asyncIterator\n  // return asyncQueue[Symbol.asyncIterator]();\n  return asyncQueue;\n}\n\nfunction isHeaderRow(row) {\n  return row.every(value => typeof value === 'string');\n}\n\nfunction hasHeader(csvText, options) {\n  if ('header' in options) {\n    return options.header;\n  }\n\n  let header = false;\n  Papa.parse(csvText, {\n    download: false,\n    dynamicTyping: true,\n    step: (results, parser) => {\n      const row = results.data;\n      header = isHeaderRow(row);\n      parser.abort();\n    }\n  });\n\n  return header;\n}\n\nfunction deduceSchema(row, headerRow) {\n  const schema = headerRow ? {} : [];\n  for (let i = 0; i < row.length; i++) {\n    const columnName = (headerRow && headerRow[i]) || i;\n    const value = row[i];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n  }\n  return schema;\n}\n"],"file":"csv-loader.js"}