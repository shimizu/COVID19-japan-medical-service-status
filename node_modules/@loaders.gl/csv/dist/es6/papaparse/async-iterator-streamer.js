import _asyncIterator from "@babel/runtime/helpers/esm/asyncIterator";
import Papa from '../libs/papaparse';
const {
  ChunkStreamer
} = Papa;
export default function AsyncIteratorStreamer(config) {
  config = config || {};
  ChunkStreamer.call(this, config);
  this.textDecoder = new TextDecoder(this._config.encoding);

  this.stream = async function (asyncIterator) {
    this._input = asyncIterator;

    try {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;

      var _iteratorError;

      try {
        for (var _iterator = _asyncIterator(asyncIterator), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {
          const chunk = _value;
          this.parseChunk(this.getStringChunk(chunk));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            await _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._finished = true;
      this.parseChunk('');
    } catch (error) {
      this._sendError(error);
    }
  };

  this._nextChunk = function nextChunk() {};

  this.getStringChunk = function (chunk) {
    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {
      stream: true
    });
  };
}
AsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);
AsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;
//# sourceMappingURL=async-iterator-streamer.js.map