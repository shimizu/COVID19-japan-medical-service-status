{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _asyncIterator from \"@babel/runtime/helpers/esm/asyncIterator\";\nimport Papa from '../libs/papaparse';\nvar ChunkStreamer = Papa.ChunkStreamer;\nexport default function AsyncIteratorStreamer(config) {\n  config = config || {};\n  ChunkStreamer.call(this, config);\n  this.textDecoder = new TextDecoder(this._config.encoding);\n\n  this.stream = function () {\n    var _ref = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(asyncIterator) {\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              this._input = asyncIterator;\n              _context.prev = 1;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context.prev = 4;\n              _iterator = _asyncIterator(asyncIterator);\n\n            case 6:\n              _context.next = 8;\n              return _iterator.next();\n\n            case 8:\n              _step = _context.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context.next = 12;\n              return _step.value;\n\n            case 12:\n              _value = _context.sent;\n\n              if (_iteratorNormalCompletion) {\n                _context.next = 19;\n                break;\n              }\n\n              chunk = _value;\n              this.parseChunk(this.getStringChunk(chunk));\n\n            case 16:\n              _iteratorNormalCompletion = true;\n              _context.next = 6;\n              break;\n\n            case 19:\n              _context.next = 25;\n              break;\n\n            case 21:\n              _context.prev = 21;\n              _context.t0 = _context[\"catch\"](4);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 25:\n              _context.prev = 25;\n              _context.prev = 26;\n\n              if (!(!_iteratorNormalCompletion && _iterator[\"return\"] != null)) {\n                _context.next = 30;\n                break;\n              }\n\n              _context.next = 30;\n              return _iterator[\"return\"]();\n\n            case 30:\n              _context.prev = 30;\n\n              if (!_didIteratorError) {\n                _context.next = 33;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 33:\n              return _context.finish(30);\n\n            case 34:\n              return _context.finish(25);\n\n            case 35:\n              this._finished = true;\n              this.parseChunk('');\n              _context.next = 42;\n              break;\n\n            case 39:\n              _context.prev = 39;\n              _context.t1 = _context[\"catch\"](1);\n\n              this._sendError(_context.t1);\n\n            case 42:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this, [[1, 39], [4, 21, 25, 35], [26,, 30, 34]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  this._nextChunk = function nextChunk() {};\n\n  this.getStringChunk = function (chunk) {\n    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {\n      stream: true\n    });\n  };\n}\nAsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);\nAsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;","map":{"version":3,"sources":["../../../src/lib/async-iterator-streamer.js"],"names":["ChunkStreamer","Papa","config","chunk","stream","AsyncIteratorStreamer","Object"],"mappings":"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","sourcesContent":["// A custom papaparse `Streamer` for async iterators\n// Ideally this can be contributed back to papaparse\n// Or papaparse can expose Streamer API so we can extend without forking.\n\n/* eslint-disable no-invalid-this */\n/* global TextDecoder */\n\n// Note: papaparse is not an ES6 module\nimport Papa from '../libs/papaparse';\nconst {ChunkStreamer} = Papa;\n\nexport default function AsyncIteratorStreamer(config) {\n  config = config || {};\n\n  ChunkStreamer.call(this, config);\n\n  this.textDecoder = new TextDecoder(this._config.encoding);\n\n  // Implement ChunkStreamer base class methods\n\n  // this.pause = function() {\n  //   ChunkStreamer.prototype.pause.apply(this, arguments);\n  // };\n\n  // this.resume = function() {\n  //   ChunkStreamer.prototype.resume.apply(this, arguments);\n  //   this._input.resume();\n  // };\n\n  this.stream = async function(asyncIterator) {\n    this._input = asyncIterator;\n\n    try {\n      // ES2018 version\n      // TODO - check for pause and abort flags?\n      for await (const chunk of asyncIterator) {\n        this.parseChunk(this.getStringChunk(chunk));\n      }\n\n      // ES5 VERSION\n      // while (true) {\n      //   asyncIterator.next().then(function(value) {\n      //     if (value.done) {\n      //       // finalize iterator?\n      //     }\n      //   }\n      //   const  = await ;\n      //   if (done) return total;\n      //   total += value.length;\n      // }\n\n      this._finished = true;\n      this.parseChunk('');\n    } catch (error) {\n      // Inform ChunkStreamer base class of error\n      this._sendError(error);\n    }\n  };\n\n  this._nextChunk = function nextChunk() {\n    // Left empty, as async iterator automatically pulls next chunk\n  };\n\n  // HELPER METHODS\n  this.getStringChunk = function(chunk) {\n    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {stream: true});\n  };\n}\n\nAsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);\nAsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;\n"]},"metadata":{},"sourceType":"module"}