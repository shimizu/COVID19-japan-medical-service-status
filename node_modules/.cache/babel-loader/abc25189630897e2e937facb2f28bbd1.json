{"ast":null,"code":"// This is a fork of papaparse\n// https://github.com/mholt/PapaParse\n\n/* @license\nPapa Parse\nv5.0.0-beta.0\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/\n// FORK SUMMARY:\n// - Adopt ES6 exports\n// - Implement new AsyncIteratorStreamer\n// - Remove non Async Iterator streamers (can all be handled by new streamer)\n// - Remove unused Worker support (loaders.gl worker system used instead)\n// - Remove unused jQuery plugin support\n\n/* eslint-disable */\n// @ts-nocheck\nvar global = function () {\n  // alternative method, similar to `Function('return this')()`\n  // but without using `eval` (which is disabled when\n  // using Content Security Policy).\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  } // When running tests none of the above have been defined\n\n\n  return {};\n}();\n\nvar IS_PAPA_WORKER = false;\nvar Papa = {};\nmodule.exports = Papa;\nPapa.parse = CsvToJson;\nPapa.unparse = JsonToCsv;\nPapa.RECORD_SEP = String.fromCharCode(30);\nPapa.UNIT_SEP = String.fromCharCode(31);\nPapa.BYTE_ORDER_MARK = '\\ufeff';\nPapa.BAD_DELIMITERS = ['\\r', '\\n', '\"', Papa.BYTE_ORDER_MARK];\nPapa.WORKERS_SUPPORTED = false; // !IS_WORKER && !!global.Worker;\n\nPapa.NODE_STREAM_INPUT = 1; // Configurable chunk sizes for local and remote files, respectively\n\nPapa.LocalChunkSize = 1024 * 1024 * 10; // 10 MB\n\nPapa.RemoteChunkSize = 1024 * 1024 * 5; // 5 MB\n\nPapa.DefaultDelimiter = ','; // Used if not specified and detection fails\n// Exposed for testing and development only\n\nPapa.Parser = Parser;\nPapa.ParserHandle = ParserHandle; // BEGIN FORK\n\nPapa.ChunkStreamer = ChunkStreamer;\nPapa.StringStreamer = StringStreamer;\n/*\nPapa.NetworkStreamer = NetworkStreamer;\nPapa.FileStreamer = FileStreamer;\nPapa.ReadableStreamStreamer = ReadableStreamStreamer;\nif (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n  Papa.DuplexStreamStreamer = DuplexStreamStreamer;\n}\n*/\n// END FORK\n// BEGIN FORK\n// Adds an argument to papa.parse\n// function CsvToJson(_input, _config)\n\nfunction CsvToJson(_input, _config, UserDefinedStreamer // BEGIN FORK\n) {\n  _config = _config || {};\n  var dynamicTyping = _config.dynamicTyping || false;\n\n  if (isFunction(dynamicTyping)) {\n    _config.dynamicTypingFunction = dynamicTyping; // Will be filled on first row call\n\n    dynamicTyping = {};\n  }\n\n  _config.dynamicTyping = dynamicTyping;\n  _config.transform = isFunction(_config.transform) ? _config.transform : false;\n\n  if (_config.worker && Papa.WORKERS_SUPPORTED) {\n    var w = newWorker();\n    w.userStep = _config.step;\n    w.userChunk = _config.chunk;\n    w.userComplete = _config.complete;\n    w.userError = _config.error;\n    _config.step = isFunction(_config.step);\n    _config.chunk = isFunction(_config.chunk);\n    _config.complete = isFunction(_config.complete);\n    _config.error = isFunction(_config.error);\n    delete _config.worker; // prevent infinite loop\n\n    w.postMessage({\n      input: _input,\n      config: _config,\n      workerId: w.id\n    });\n    return;\n  }\n\n  var streamer = null;\n  /*\n  if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n    // create a node Duplex stream for use\n    // with .pipe\n    streamer = new DuplexStreamStreamer(_config);\n    return streamer.getStream();\n  } else\n  */\n\n  if (typeof _input === 'string') {\n    // if (_config.download) streamer = new NetworkStreamer(_config);\n    // else\n    streamer = new StringStreamer(_config);\n  }\n  /*\n  else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on)) {\n    streamer = new ReadableStreamStreamer(_config);\n  } else if ((global.File && _input instanceof File) || _input instanceof Object)\n    // ...Safari. (see issue #106)\n    streamer = new FileStreamer(_config);\n  */\n  // BEGIN FORK\n\n\n  if (!streamer) {\n    streamer = new UserDefinedStreamer(_config);\n  } // END FORK\n\n\n  return streamer.stream(_input);\n}\n\nfunction JsonToCsv(_input, _config) {\n  // Default configuration\n\n  /** whether to surround every datum with quotes */\n  var _quotes = false;\n  /** whether to write headers */\n\n  var _writeHeader = true;\n  /** delimiting character(s) */\n\n  var _delimiter = ',';\n  /** newline character(s) */\n\n  var _newline = '\\r\\n';\n  /** quote character */\n\n  var _quoteChar = '\"';\n  /** escaped quote character, either \"\" or <config.escapeChar>\" */\n\n  var _escapedQuote = _quoteChar + _quoteChar;\n  /** whether to skip empty lines */\n\n\n  var _skipEmptyLines = false;\n  /** the columns (keys) we expect when we unparse objects */\n\n  var _columns = null;\n  unpackConfig();\n  var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');\n  if (typeof _input === 'string') _input = JSON.parse(_input);\n\n  if (Array.isArray(_input)) {\n    if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);else if (typeof _input[0] === 'object') return serialize(_columns || objectKeys(_input[0]), _input, _skipEmptyLines);\n  } else if (typeof _input === 'object') {\n    if (typeof _input.data === 'string') _input.data = JSON.parse(_input.data);\n\n    if (Array.isArray(_input.data)) {\n      if (!_input.fields) _input.fields = _input.meta && _input.meta.fields;\n      if (!_input.fields) _input.fields = Array.isArray(_input.data[0]) ? _input.fields : objectKeys(_input.data[0]);\n      if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== 'object') _input.data = [_input.data]; // handles input like [1,2,3] or ['asdf']\n    }\n\n    return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);\n  } // Default (any valid paths should return before this)\n\n\n  throw new Error('Unable to serialize unrecognized input');\n\n  function unpackConfig() {\n    if (typeof _config !== 'object') return;\n\n    if (typeof _config.delimiter === 'string' && !Papa.BAD_DELIMITERS.filter(function (value) {\n      return _config.delimiter.indexOf(value) !== -1;\n    }).length) {\n      _delimiter = _config.delimiter;\n    }\n\n    if (typeof _config.quotes === 'boolean' || Array.isArray(_config.quotes)) _quotes = _config.quotes;\n    if (typeof _config.skipEmptyLines === 'boolean' || typeof _config.skipEmptyLines === 'string') _skipEmptyLines = _config.skipEmptyLines;\n    if (typeof _config.newline === 'string') _newline = _config.newline;\n    if (typeof _config.quoteChar === 'string') _quoteChar = _config.quoteChar;\n    if (typeof _config.header === 'boolean') _writeHeader = _config.header;\n\n    if (Array.isArray(_config.columns)) {\n      if (_config.columns.length === 0) throw new Error('Option columns is empty');\n      _columns = _config.columns;\n    }\n\n    if (_config.escapeChar !== undefined) {\n      _escapedQuote = _config.escapeChar + _quoteChar;\n    }\n  }\n  /** Turns an object's keys into an array */\n\n\n  function objectKeys(obj) {\n    if (typeof obj !== 'object') return [];\n    var keys = [];\n\n    for (var key in obj) keys.push(key);\n\n    return keys;\n  }\n  /** The double for loop that iterates the data and writes out a CSV string including header row */\n\n\n  function serialize(fields, data, skipEmptyLines) {\n    var csv = '';\n    if (typeof fields === 'string') fields = JSON.parse(fields);\n    if (typeof data === 'string') data = JSON.parse(data);\n    var hasHeader = Array.isArray(fields) && fields.length > 0;\n    var dataKeyedByField = !Array.isArray(data[0]); // If there a header row, write it first\n\n    if (hasHeader && _writeHeader) {\n      for (var i = 0; i < fields.length; i++) {\n        if (i > 0) csv += _delimiter;\n        csv += safe(fields[i], i);\n      }\n\n      if (data.length > 0) csv += _newline;\n    } // Then write out the data\n\n\n    for (var row = 0; row < data.length; row++) {\n      var maxCol = hasHeader ? fields.length : data[row].length;\n      var emptyLine = false;\n      var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;\n\n      if (skipEmptyLines && !hasHeader) {\n        emptyLine = skipEmptyLines === 'greedy' ? data[row].join('').trim() === '' : data[row].length === 1 && data[row][0].length === 0;\n      }\n\n      if (skipEmptyLines === 'greedy' && hasHeader) {\n        var line = [];\n\n        for (var c = 0; c < maxCol; c++) {\n          var cx = dataKeyedByField ? fields[c] : c;\n          line.push(data[row][cx]);\n        }\n\n        emptyLine = line.join('').trim() === '';\n      }\n\n      if (!emptyLine) {\n        for (var col = 0; col < maxCol; col++) {\n          if (col > 0 && !nullLine) csv += _delimiter;\n          var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n          csv += safe(data[row][colIdx], col);\n        }\n\n        if (row < data.length - 1 && (!skipEmptyLines || maxCol > 0 && !nullLine)) {\n          csv += _newline;\n        }\n      }\n    }\n\n    return csv;\n  }\n  /** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n\n\n  function safe(str, col) {\n    if (typeof str === 'undefined' || str === null) return '';\n    if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);\n    str = str.toString().replace(quoteCharRegex, _escapedQuote);\n    var needsQuotes = typeof _quotes === 'boolean' && _quotes || Array.isArray(_quotes) && _quotes[col] || hasAny(str, Papa.BAD_DELIMITERS) || str.indexOf(_delimiter) > -1 || str.charAt(0) === ' ' || str.charAt(str.length - 1) === ' ';\n    return needsQuotes ? _quoteChar + str + _quoteChar : str;\n  }\n\n  function hasAny(str, substrings) {\n    for (var i = 0; i < substrings.length; i++) if (str.indexOf(substrings[i]) > -1) return true;\n\n    return false;\n  }\n}\n/** ChunkStreamer is the base prototype for various streamer implementations. */\n\n\nfunction ChunkStreamer(config) {\n  this._handle = null;\n  this._finished = false;\n  this._completed = false;\n  this._input = null;\n  this._baseIndex = 0;\n  this._partialLine = '';\n  this._rowCount = 0;\n  this._start = 0;\n  this._nextChunk = null;\n  this.isFirstChunk = true;\n  this._completeResults = {\n    data: [],\n    errors: [],\n    meta: {}\n  };\n  replaceConfig.call(this, config);\n\n  this.parseChunk = function (chunk, isFakeChunk) {\n    // First chunk pre-processing\n    if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {\n      var modifiedChunk = this._config.beforeFirstChunk(chunk);\n\n      if (modifiedChunk !== undefined) chunk = modifiedChunk;\n    }\n\n    this.isFirstChunk = false; // Rejoin the line we likely just split in two by chunking the file\n\n    var aggregate = this._partialLine + chunk;\n    this._partialLine = '';\n\n    var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\n    if (this._handle.paused() || this._handle.aborted()) return;\n    var lastIndex = results.meta.cursor;\n\n    if (!this._finished) {\n      this._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n      this._baseIndex = lastIndex;\n    }\n\n    if (results && results.data) this._rowCount += results.data.length;\n    var finishedIncludingPreview = this._finished || this._config.preview && this._rowCount >= this._config.preview;\n\n    if (IS_PAPA_WORKER) {\n      global.postMessage({\n        results: results,\n        workerId: Papa.WORKER_ID,\n        finished: finishedIncludingPreview\n      });\n    } else if (isFunction(this._config.chunk) && !isFakeChunk) {\n      this._config.chunk(results, this._handle);\n\n      if (this._handle.paused() || this._handle.aborted()) return;\n      results = undefined;\n      this._completeResults = undefined;\n    }\n\n    if (!this._config.step && !this._config.chunk) {\n      this._completeResults.data = this._completeResults.data.concat(results.data);\n      this._completeResults.errors = this._completeResults.errors.concat(results.errors);\n      this._completeResults.meta = results.meta;\n    }\n\n    if (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {\n      this._config.complete(this._completeResults, this._input);\n\n      this._completed = true;\n    }\n\n    if (!finishedIncludingPreview && (!results || !results.meta.paused)) this._nextChunk();\n    return results;\n  };\n\n  this._sendError = function (error) {\n    if (isFunction(this._config.error)) this._config.error(error);else if (IS_PAPA_WORKER && this._config.error) {\n      global.postMessage({\n        workerId: Papa.WORKER_ID,\n        error: error,\n        finished: false\n      });\n    }\n  };\n\n  function replaceConfig(config) {\n    // Deep-copy the config so we can edit it\n    var configCopy = copy(config);\n    configCopy.chunkSize = parseInt(configCopy.chunkSize); // parseInt VERY important so we don't concatenate strings!\n\n    if (!config.step && !config.chunk) configCopy.chunkSize = null; // disable Range header if not streaming; bad values break IIS - see issue #196\n\n    this._handle = new ParserHandle(configCopy);\n    this._handle.streamer = this;\n    this._config = configCopy; // persist the copy to the caller\n  }\n}\n/*\nfunction NetworkStreamer(config) {\n  config = config || {};\n  if (!config.chunkSize) config.chunkSize = Papa.RemoteChunkSize;\n  ChunkStreamer.call(this, config);\n\n  var xhr;\n\n  if (IS_WORKER) {\n    this._nextChunk = function() {\n      this._readChunk();\n      this._chunkLoaded();\n    };\n  } else {\n    this._nextChunk = function() {\n      this._readChunk();\n    };\n  }\n\n  this.stream = function(url) {\n    this._input = url;\n    this._nextChunk(); // Starts streaming\n  };\n\n  this._readChunk = function() {\n    if (this._finished) {\n      this._chunkLoaded();\n      return;\n    }\n\n    xhr = new XMLHttpRequest();\n\n    if (this._config.withCredentials) {\n      xhr.withCredentials = this._config.withCredentials;\n    }\n\n    if (!IS_WORKER) {\n      xhr.onload = bindFunction(this._chunkLoaded, this);\n      xhr.onerror = bindFunction(this._chunkError, this);\n    }\n\n    xhr.open('GET', this._input, !IS_WORKER);\n    // Headers can only be set when once the request state is OPENED\n    if (this._config.downloadRequestHeaders) {\n      var headers = this._config.downloadRequestHeaders;\n\n      for (var headerName in headers) {\n        xhr.setRequestHeader(headerName, headers[headerName]);\n      }\n    }\n\n    if (this._config.chunkSize) {\n      var end = this._start + this._config.chunkSize - 1; // minus one because byte range is inclusive\n      xhr.setRequestHeader('Range', 'bytes=' + this._start + '-' + end);\n    }\n\n    try {\n      xhr.send();\n    } catch (err) {\n      this._chunkError(err.message);\n    }\n\n    if (IS_WORKER && xhr.status === 0) this._chunkError();\n    else this._start += this._config.chunkSize;\n  };\n\n  this._chunkLoaded = function() {\n    if (xhr.readyState !== 4) return;\n\n    if (xhr.status < 200 || xhr.status >= 400) {\n      this._chunkError();\n      return;\n    }\n\n    this._finished = !this._config.chunkSize || this._start > getFileSize(xhr);\n    this.parseChunk(xhr.responseText);\n  };\n\n  this._chunkError = function(errorMessage) {\n    var errorText = xhr.statusText || errorMessage;\n    this._sendError(new Error(errorText));\n  };\n\n  function getFileSize(xhr) {\n    var contentRange = xhr.getResponseHeader('Content-Range');\n    if (contentRange === null) {\n      // no content range, then finish!\n      return -1;\n    }\n    return parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));\n  }\n}\nNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\nNetworkStreamer.prototype.constructor = NetworkStreamer;\n\nfunction FileStreamer(config) {\n  config = config || {};\n  if (!config.chunkSize) config.chunkSize = Papa.LocalChunkSize;\n  ChunkStreamer.call(this, config);\n\n  var reader, slice;\n\n  // FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n  // But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n  var usingAsyncReader = typeof FileReader !== 'undefined'; // Safari doesn't consider it a function - see issue #105\n\n  this.stream = function(file) {\n    this._input = file;\n    slice = file.slice || file.webkitSlice || file.mozSlice;\n\n    if (usingAsyncReader) {\n      reader = new FileReader(); // Preferred method of reading files, even in workers\n      reader.onload = bindFunction(this._chunkLoaded, this);\n      reader.onerror = bindFunction(this._chunkError, this);\n    } else reader = new FileReaderSync(); // Hack for running in a web worker in Firefox\n\n    this._nextChunk(); // Starts streaming\n  };\n\n  this._nextChunk = function() {\n    if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n      this._readChunk();\n  };\n\n  this._readChunk = function() {\n    var input = this._input;\n    if (this._config.chunkSize) {\n      var end = Math.min(this._start + this._config.chunkSize, this._input.size);\n      input = slice.call(input, this._start, end);\n    }\n    var txt = reader.readAsText(input, this._config.encoding);\n    if (!usingAsyncReader) this._chunkLoaded({target: {result: txt}}); // mimic the async signature\n  };\n\n  this._chunkLoaded = function(event) {\n    // Very important to increment start each time before handling results\n    this._start += this._config.chunkSize;\n    this._finished = !this._config.chunkSize || this._start >= this._input.size;\n    this.parseChunk(event.target.result);\n  };\n\n  this._chunkError = function() {\n    this._sendError(reader.error);\n  };\n}\nFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\nFileStreamer.prototype.constructor = FileStreamer;\n*/\n\n\nfunction StringStreamer(config) {\n  config = config || {};\n  ChunkStreamer.call(this, config);\n  var remaining;\n\n  this.stream = function (s) {\n    remaining = s;\n    return this._nextChunk();\n  };\n\n  this._nextChunk = function () {\n    if (this._finished) return;\n    var size = this._config.chunkSize;\n    var chunk = size ? remaining.substr(0, size) : remaining;\n    remaining = size ? remaining.substr(size) : '';\n    this._finished = !remaining;\n    return this.parseChunk(chunk);\n  };\n}\n\nStringStreamer.prototype = Object.create(StringStreamer.prototype);\nStringStreamer.prototype.constructor = StringStreamer;\n/*\nfunction ReadableStreamStreamer(config) {\n  config = config || {};\n\n  ChunkStreamer.call(this, config);\n\n  var queue = [];\n  var parseOnData = true;\n  var streamHasEnded = false;\n\n  this.pause = function() {\n    ChunkStreamer.prototype.pause.apply(this, arguments);\n    this._input.pause();\n  };\n\n  this.resume = function() {\n    ChunkStreamer.prototype.resume.apply(this, arguments);\n    this._input.resume();\n  };\n\n  this.stream = function(stream) {\n    this._input = stream;\n\n    this._input.on('data', this._streamData);\n    this._input.on('end', this._streamEnd);\n    this._input.on('error', this._streamError);\n  };\n\n  this._checkIsFinished = function() {\n    if (streamHasEnded && queue.length === 1) {\n      this._finished = true;\n    }\n  };\n\n  this._nextChunk = function() {\n    this._checkIsFinished();\n    if (queue.length) {\n      this.parseChunk(queue.shift());\n    } else {\n      parseOnData = true;\n    }\n  };\n\n  this._streamData = bindFunction(function(chunk) {\n    try {\n      queue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));\n\n      if (parseOnData) {\n        parseOnData = false;\n        this._checkIsFinished();\n        this.parseChunk(queue.shift());\n      }\n    } catch (error) {\n      this._streamError(error);\n    }\n  }, this);\n\n  this._streamError = bindFunction(function(error) {\n    this._streamCleanUp();\n    this._sendError(error);\n  }, this);\n\n  this._streamEnd = bindFunction(function() {\n    this._streamCleanUp();\n    streamHasEnded = true;\n    this._streamData('');\n  }, this);\n\n  this._streamCleanUp = bindFunction(function() {\n    this._input.removeListener('data', this._streamData);\n    this._input.removeListener('end', this._streamEnd);\n    this._input.removeListener('error', this._streamError);\n  }, this);\n}\nReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\nReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n\nfunction DuplexStreamStreamer(_config) {\n  var Duplex = require('stream').Duplex;\n  var config = copy(_config);\n  var parseOnWrite = true;\n  var writeStreamHasFinished = false;\n  var parseCallbackQueue = [];\n  var stream = null;\n\n  this._onCsvData = function(results) {\n    var data = results.data;\n    if (!stream.push(data) && !this._handle.paused()) {\n      // the writeable consumer buffer has filled up\n      // so we need to pause until more items\n      // can be processed\n      this._handle.pause();\n    }\n  };\n\n  this._onCsvComplete = function() {\n    // node will finish the read stream when\n    // null is pushed\n    stream.push(null);\n  };\n\n  config.step = bindFunction(this._onCsvData, this);\n  config.complete = bindFunction(this._onCsvComplete, this);\n  ChunkStreamer.call(this, config);\n\n  this._nextChunk = function() {\n    if (writeStreamHasFinished && parseCallbackQueue.length === 1) {\n      this._finished = true;\n    }\n    if (parseCallbackQueue.length) {\n      parseCallbackQueue.shift()();\n    } else {\n      parseOnWrite = true;\n    }\n  };\n\n  this._addToParseQueue = function(chunk, callback) {\n    // add to queue so that we can indicate\n    // completion via callback\n    // node will automatically pause the incoming stream\n    // when too many items have been added without their\n    // callback being invoked\n    parseCallbackQueue.push(\n      bindFunction(function() {\n        this.parseChunk(typeof chunk === 'string' ? chunk : chunk.toString(config.encoding));\n        if (isFunction(callback)) {\n          return callback();\n        }\n      }, this)\n    );\n    if (parseOnWrite) {\n      parseOnWrite = false;\n      this._nextChunk();\n    }\n  };\n\n  this._onRead = function() {\n    if (this._handle.paused()) {\n      // the writeable consumer can handle more data\n      // so resume the chunk parsing\n      this._handle.resume();\n    }\n  };\n\n  this._onWrite = function(chunk, encoding, callback) {\n    this._addToParseQueue(chunk, callback);\n  };\n\n  this._onWriteComplete = function() {\n    writeStreamHasFinished = true;\n    // have to write empty string\n    // so parser knows its done\n    this._addToParseQueue('');\n  };\n\n  this.getStream = function() {\n    return stream;\n  };\n  stream = new Duplex({\n    readableObjectMode: true,\n    decodeStrings: false,\n    read: bindFunction(this._onRead, this),\n    write: bindFunction(this._onWrite, this)\n  });\n  stream.once('finish', bindFunction(this._onWriteComplete, this));\n}\nif (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n  DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n  DuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;\n}\n*/\n// Use one ParserHandle per entire CSV file or string\n\nfunction ParserHandle(_config) {\n  // One goal is to minimize the use of regular expressions...\n  var FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n  var ISO_DATE = /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/;\n  var self = this;\n  var _stepCounter = 0; // Number of times step was called (number of rows parsed)\n\n  var _rowCounter = 0; // Number of rows that have been parsed so far\n\n  var _input; // The input being parsed\n\n\n  var _parser; // The core parser being used\n\n\n  var _paused = false; // Whether we are paused or not\n\n  var _aborted = false; // Whether the parser has aborted or not\n\n  var _delimiterError; // Temporary state between delimiter detection and processing results\n\n\n  var _fields = []; // Fields are from the header row of the input, if there is one\n\n  var _results = {\n    // The last results returned from the parser\n    data: [],\n    errors: [],\n    meta: {}\n  };\n\n  if (isFunction(_config.step)) {\n    var userStep = _config.step;\n\n    _config.step = function (results) {\n      _results = results;\n      if (needsHeaderRow()) processResults(); // only call user's step function after header row\n      else {\n          processResults(); // It's possbile that this line was empty and there's no row here after all\n\n          if (_results.data.length === 0) return;\n          _stepCounter += results.data.length;\n          if (_config.preview && _stepCounter > _config.preview) _parser.abort();else userStep(_results, self);\n        }\n    };\n  }\n  /**\n   * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n   * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n   * when an input comes in multiple chunks, like from a file.\n   */\n\n\n  this.parse = function (input, baseIndex, ignoreLastRow) {\n    var quoteChar = _config.quoteChar || '\"';\n    if (!_config.newline) _config.newline = guessLineEndings(input, quoteChar);\n    _delimiterError = false;\n\n    if (!_config.delimiter) {\n      var delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess);\n      if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;else {\n        _delimiterError = true; // add error after parsing (otherwise it would be overwritten)\n\n        _config.delimiter = Papa.DefaultDelimiter;\n      }\n      _results.meta.delimiter = _config.delimiter;\n    } else if (isFunction(_config.delimiter)) {\n      _config.delimiter = _config.delimiter(input);\n      _results.meta.delimiter = _config.delimiter;\n    }\n\n    var parserConfig = copy(_config);\n    if (_config.preview && _config.header) parserConfig.preview++; // to compensate for header row\n\n    _input = input;\n    _parser = new Parser(parserConfig);\n    _results = _parser.parse(_input, baseIndex, ignoreLastRow);\n    processResults();\n    return _paused ? {\n      meta: {\n        paused: true\n      }\n    } : _results || {\n      meta: {\n        paused: false\n      }\n    };\n  };\n\n  this.paused = function () {\n    return _paused;\n  };\n\n  this.pause = function () {\n    _paused = true;\n\n    _parser.abort();\n\n    _input = _input.substr(_parser.getCharIndex());\n  };\n\n  this.resume = function () {\n    _paused = false;\n    self.streamer.parseChunk(_input, true);\n  };\n\n  this.aborted = function () {\n    return _aborted;\n  };\n\n  this.abort = function () {\n    _aborted = true;\n\n    _parser.abort();\n\n    _results.meta.aborted = true;\n    if (isFunction(_config.complete)) _config.complete(_results);\n    _input = '';\n  };\n\n  function testEmptyLine(s) {\n    return _config.skipEmptyLines === 'greedy' ? s.join('').trim() === '' : s.length === 1 && s[0].length === 0;\n  }\n\n  function processResults() {\n    if (_results && _delimiterError) {\n      addError('Delimiter', 'UndetectableDelimiter', \"Unable to auto-detect delimiting character; defaulted to '\" + Papa.DefaultDelimiter + \"'\");\n      _delimiterError = false;\n    }\n\n    if (_config.skipEmptyLines) {\n      for (var i = 0; i < _results.data.length; i++) if (testEmptyLine(_results.data[i])) _results.data.splice(i--, 1);\n    }\n\n    if (needsHeaderRow()) fillHeaderFields();\n    return applyHeaderAndDynamicTypingAndTransformation();\n  }\n\n  function needsHeaderRow() {\n    return _config.header && _fields.length === 0;\n  }\n\n  function fillHeaderFields() {\n    if (!_results) return;\n\n    function addHeder(header) {\n      if (isFunction(_config.transformHeader)) header = _config.transformHeader(header);\n\n      _fields.push(header);\n    }\n\n    if (Array.isArray(_results.data[0])) {\n      for (var i = 0; needsHeaderRow() && i < _results.data.length; i++) _results.data[i].forEach(addHeder);\n\n      _results.data.splice(0, 1);\n    } // if _results.data[0] is not an array, we are in a step where _results.data is the row.\n    else _results.data.forEach(addHeder);\n  }\n\n  function shouldApplyDynamicTyping(field) {\n    // Cache function values to avoid calling it for each row\n    if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n      _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n    }\n\n    return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;\n  }\n\n  function parseDynamic(field, value) {\n    if (shouldApplyDynamicTyping(field)) {\n      if (value === 'true' || value === 'TRUE') return true;else if (value === 'false' || value === 'FALSE') return false;else if (FLOAT.test(value)) return parseFloat(value);else if (ISO_DATE.test(value)) return new Date(value);else return value === '' ? null : value;\n    }\n\n    return value;\n  }\n\n  function applyHeaderAndDynamicTypingAndTransformation() {\n    if (!_results || !_config.header && !_config.dynamicTyping && !_config.transform) return _results;\n\n    function processRow(rowSource, i) {\n      var row = _config.header ? {} : [];\n      var j;\n\n      for (j = 0; j < rowSource.length; j++) {\n        var field = j;\n        var value = rowSource[j];\n        if (_config.header) field = j >= _fields.length ? '__parsed_extra' : _fields[j];\n        if (_config.transform) value = _config.transform(value, field);\n        value = parseDynamic(field, value);\n\n        if (field === '__parsed_extra') {\n          row[field] = row[field] || [];\n          row[field].push(value);\n        } else row[field] = value;\n      }\n\n      if (_config.header) {\n        if (j > _fields.length) addError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);else if (j < _fields.length) addError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);\n      }\n\n      return row;\n    }\n\n    var incrementBy = 1;\n\n    if (!_results.data[0] || Array.isArray(_results.data[0])) {\n      _results.data = _results.data.map(processRow);\n      incrementBy = _results.data.length;\n    } else _results.data = processRow(_results.data, 0);\n\n    if (_config.header && _results.meta) _results.meta.fields = _fields;\n    _rowCounter += incrementBy;\n    return _results;\n  }\n\n  function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {\n    var bestDelim, bestDelta, fieldCountPrevRow;\n    delimitersToGuess = delimitersToGuess || [',', '\\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];\n\n    for (var i = 0; i < delimitersToGuess.length; i++) {\n      var delim = delimitersToGuess[i];\n      var delta = 0,\n          avgFieldCount = 0,\n          emptyLinesCount = 0;\n      fieldCountPrevRow = undefined;\n      var preview = new Parser({\n        comments: comments,\n        delimiter: delim,\n        newline: newline,\n        preview: 10\n      }).parse(input);\n\n      for (var j = 0; j < preview.data.length; j++) {\n        if (skipEmptyLines && testEmptyLine(preview.data[j])) {\n          emptyLinesCount++;\n          continue;\n        }\n\n        var fieldCount = preview.data[j].length;\n        avgFieldCount += fieldCount;\n\n        if (typeof fieldCountPrevRow === 'undefined') {\n          fieldCountPrevRow = 0;\n          continue;\n        } else if (fieldCount > 1) {\n          delta += Math.abs(fieldCount - fieldCountPrevRow);\n          fieldCountPrevRow = fieldCount;\n        }\n      }\n\n      if (preview.data.length > 0) avgFieldCount /= preview.data.length - emptyLinesCount;\n\n      if ((typeof bestDelta === 'undefined' || delta > bestDelta) && avgFieldCount > 1.99) {\n        bestDelta = delta;\n        bestDelim = delim;\n      }\n    }\n\n    _config.delimiter = bestDelim;\n    return {\n      successful: !!bestDelim,\n      bestDelimiter: bestDelim\n    };\n  }\n\n  function guessLineEndings(input, quoteChar) {\n    input = input.substr(0, 1024 * 1024); // max length 1 MB\n    // Replace all the text inside quotes\n\n    var re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');\n    input = input.replace(re, '');\n    var r = input.split('\\r');\n    var n = input.split('\\n');\n    var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;\n    if (r.length === 1 || nAppearsFirst) return '\\n';\n    var numWithN = 0;\n\n    for (var i = 0; i < r.length; i++) {\n      if (r[i][0] === '\\n') numWithN++;\n    }\n\n    return numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n  }\n\n  function addError(type, code, msg, row) {\n    _results.errors.push({\n      type: type,\n      code: code,\n      message: msg,\n      row: row\n    });\n  }\n}\n/** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */\n\n\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n/** The core parser implements speedy and correct CSV parsing */\n\n\nfunction Parser(config) {\n  // Unpack the config object\n  config = config || {};\n  var delim = config.delimiter;\n  var newline = config.newline;\n  var comments = config.comments;\n  var step = config.step;\n  var preview = config.preview;\n  var fastMode = config.fastMode;\n  var quoteChar;\n  /** Allows for no quoteChar by setting quoteChar to undefined in config */\n\n  if (config.quoteChar === undefined) {\n    quoteChar = '\"';\n  } else {\n    quoteChar = config.quoteChar;\n  }\n\n  var escapeChar = quoteChar;\n\n  if (config.escapeChar !== undefined) {\n    escapeChar = config.escapeChar;\n  } // Delimiter must be valid\n\n\n  if (typeof delim !== 'string' || Papa.BAD_DELIMITERS.indexOf(delim) > -1) delim = ','; // Comment character must be valid\n\n  if (comments === delim) throw new Error('Comment character same as delimiter');else if (comments === true) comments = '#';else if (typeof comments !== 'string' || Papa.BAD_DELIMITERS.indexOf(comments) > -1) comments = false; // Newline must be valid: \\r, \\n, or \\r\\n\n\n  if (newline !== '\\n' && newline !== '\\r' && newline !== '\\r\\n') newline = '\\n'; // We're gonna need these at the Parser scope\n\n  var cursor = 0;\n  var aborted = false;\n\n  this.parse = function (input, baseIndex, ignoreLastRow) {\n    // For some reason, in Chrome, this speeds things up (!?)\n    if (typeof input !== 'string') throw new Error('Input must be a string'); // We don't need to compute some of these every time parse() is called,\n    // but having them in a more local scope seems to perform better\n\n    var inputLen = input.length,\n        delimLen = delim.length,\n        newlineLen = newline.length,\n        commentsLen = comments.length;\n    var stepIsFunction = isFunction(step); // Establish starting state\n\n    cursor = 0;\n    var data = [],\n        errors = [],\n        row = [],\n        lastCursor = 0;\n    if (!input) return returnable();\n\n    if (fastMode || fastMode !== false && input.indexOf(quoteChar) === -1) {\n      var rows = input.split(newline);\n\n      for (var i = 0; i < rows.length; i++) {\n        row = rows[i];\n        cursor += row.length;\n        if (i !== rows.length - 1) cursor += newline.length;else if (ignoreLastRow) return returnable();\n        if (comments && row.substr(0, commentsLen) === comments) continue;\n\n        if (stepIsFunction) {\n          data = [];\n          pushRow(row.split(delim));\n          doStep();\n          if (aborted) return returnable();\n        } else pushRow(row.split(delim));\n\n        if (preview && i >= preview) {\n          data = data.slice(0, preview);\n          return returnable(true);\n        }\n      }\n\n      return returnable();\n    }\n\n    var nextDelim = input.indexOf(delim, cursor);\n    var nextNewline = input.indexOf(newline, cursor);\n    var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');\n    var quoteSearch; // Parser loop\n\n    for (;;) {\n      // Field has opening quote\n      if (input[cursor] === quoteChar) {\n        // Start our search for the closing quote where the cursor is\n        quoteSearch = cursor; // Skip the opening quote\n\n        cursor++;\n\n        for (;;) {\n          // Find closing quote\n          quoteSearch = input.indexOf(quoteChar, quoteSearch + 1); //No other quotes are found - no other delimiters\n\n          if (quoteSearch === -1) {\n            if (!ignoreLastRow) {\n              // No closing quote... what a pity\n              errors.push({\n                type: 'Quotes',\n                code: 'MissingQuotes',\n                message: 'Quoted field unterminated',\n                row: data.length,\n                // row has yet to be inserted\n                index: cursor\n              });\n            }\n\n            return finish();\n          } // Closing quote at EOF\n\n\n          if (quoteSearch === inputLen - 1) {\n            var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n            return finish(value);\n          } // If this quote is escaped, it's part of the data; skip it\n          // If the quote character is the escape character, then check if the next character is the escape character\n\n\n          if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {\n            quoteSearch++;\n            continue;\n          } // If the quote character is not the escape character, then check if the previous character was the escape character\n\n\n          if (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar) {\n            continue;\n          } // Check up to nextDelim or nextNewline, whichever is closest\n\n\n          var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);\n          var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo); // Closing quote followed by delimiter or 'unnecessary spaces + delimiter'\n\n          if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim) {\n            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n            cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;\n            nextDelim = input.indexOf(delim, cursor);\n            nextNewline = input.indexOf(newline, cursor);\n            break;\n          }\n\n          var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline); // Closing quote followed by newline or 'unnecessary spaces + newLine'\n\n          if (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, newlineLen) === newline) {\n            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n            saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);\n            nextDelim = input.indexOf(delim, cursor); // because we may have skipped the nextDelim in the quoted field\n\n            if (stepIsFunction) {\n              doStep();\n              if (aborted) return returnable();\n            }\n\n            if (preview && data.length >= preview) return returnable(true);\n            break;\n          } // Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string\n\n\n          errors.push({\n            type: 'Quotes',\n            code: 'InvalidQuotes',\n            message: 'Trailing quote on quoted field is malformed',\n            row: data.length,\n            // row has yet to be inserted\n            index: cursor\n          });\n          quoteSearch++;\n          continue;\n        }\n\n        continue;\n      } // Comment found at start of new line\n\n\n      if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments) {\n        if (nextNewline === -1) // Comment ends at EOF\n          return returnable();\n        cursor = nextNewline + newlineLen;\n        nextNewline = input.indexOf(newline, cursor);\n        nextDelim = input.indexOf(delim, cursor);\n        continue;\n      } // Next delimiter comes before next newline, so we've reached end of field\n\n\n      if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {\n        row.push(input.substring(cursor, nextDelim));\n        cursor = nextDelim + delimLen;\n        nextDelim = input.indexOf(delim, cursor);\n        continue;\n      } // End of row\n\n\n      if (nextNewline !== -1) {\n        row.push(input.substring(cursor, nextNewline));\n        saveRow(nextNewline + newlineLen);\n\n        if (stepIsFunction) {\n          doStep();\n          if (aborted) return returnable();\n        }\n\n        if (preview && data.length >= preview) return returnable(true);\n        continue;\n      }\n\n      break;\n    }\n\n    return finish();\n\n    function pushRow(row) {\n      data.push(row);\n      lastCursor = cursor;\n    }\n    /**\n     * checks if there are extra spaces after closing quote and given index without any text\n     * if Yes, returns the number of spaces\n     */\n\n\n    function extraSpaces(index) {\n      var spaceLength = 0;\n\n      if (index !== -1) {\n        var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);\n\n        if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {\n          spaceLength = textBetweenClosingQuoteAndIndex.length;\n        }\n      }\n\n      return spaceLength;\n    }\n    /**\n     * Appends the remaining input from cursor to the end into\n     * row, saves the row, calls step, and returns the results.\n     */\n\n\n    function finish(value) {\n      if (ignoreLastRow) return returnable();\n      if (typeof value === 'undefined') value = input.substr(cursor);\n      row.push(value);\n      cursor = inputLen; // important in case parsing is paused\n\n      pushRow(row);\n      if (stepIsFunction) doStep();\n      return returnable();\n    }\n    /**\n     * Appends the current row to the results. It sets the cursor\n     * to newCursor and finds the nextNewline. The caller should\n     * take care to execute user's step function and check for\n     * preview and end parsing if necessary.\n     */\n\n\n    function saveRow(newCursor) {\n      cursor = newCursor;\n      pushRow(row);\n      row = [];\n      nextNewline = input.indexOf(newline, cursor);\n    }\n    /** Returns an object with the results, errors, and meta. */\n\n\n    function returnable(stopped, step) {\n      var isStep = step || false;\n      return {\n        data: isStep ? data[0] : data,\n        errors: errors,\n        meta: {\n          delimiter: delim,\n          linebreak: newline,\n          aborted: aborted,\n          truncated: !!stopped,\n          cursor: lastCursor + (baseIndex || 0)\n        }\n      };\n    }\n    /** Executes the user's step function and resets data & errors. */\n\n\n    function doStep() {\n      step(returnable(undefined, true));\n      data = [];\n      errors = [];\n    }\n  };\n  /** Sets the abort flag */\n\n\n  this.abort = function () {\n    aborted = true;\n  };\n  /** Gets the cursor position */\n\n\n  this.getCharIndex = function () {\n    return cursor;\n  };\n}\n/*\nfunction getWorkerBlob() {\n\tvar URL = global.URL || global.webkitURL || null;\n\tvar code = moduleFactory.toString();\n\treturn Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob(['(', code, ')();'], {type: 'text/javascript'})));\n}\n\nvar IS_WORKER = !global.document && !!global.postMessage,\n\tIS_PAPA_WORKER = IS_WORKER && /blob:/i.test((global.location || {}).protocol);\nvar workers = {}, workerIdCounter = 0;\n\nfunction newWorker()\n{\n\tif (!Papa.WORKERS_SUPPORTED)\n\t\treturn false;\n\n\tvar workerUrl = getWorkerBlob();\n\tvar w = new global.Worker(workerUrl);\n\tw.onmessage = mainThreadReceivedMessage;\n\tw.id = workerIdCounter++;\n\tworkers[w.id] = w;\n\treturn w;\n}\n\n// Callback when main thread receives a message\nfunction mainThreadReceivedMessage(e)\n{\n\tvar msg = e.data;\n\tvar worker = workers[msg.workerId];\n\tvar aborted = false;\n\n\tif (msg.error)\n\t\tworker.userError(msg.error, msg.file);\n\telse if (msg.results && msg.results.data)\n\t{\n\t\tvar abort = function() {\n\t\t\taborted = true;\n\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t};\n\n\t\tvar handle = {\n\t\t\tabort: abort,\n\t\t\tpause: notImplemented,\n\t\t\tresume: notImplemented\n\t\t};\n\n\t\tif (isFunction(worker.userStep))\n\t\t{\n\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t{\n\t\t\t\tworker.userStep({\n\t\t\t\t\tdata: msg.results.data[i],\n\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t}, handle);\n\t\t\t\tif (aborted)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t}\n\t\telse if (isFunction(worker.userChunk))\n\t\t{\n\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\tdelete msg.results;\n\t\t}\n\t}\n\n\tif (msg.finished && !aborted)\n\t\tcompleteWorker(msg.workerId, msg.results);\n}\n\nfunction completeWorker(workerId, results) {\n\tvar worker = workers[workerId];\n\tif (isFunction(worker.userComplete))\n\t\tworker.userComplete(results);\n\tworker.terminate();\n\tdelete workers[workerId];\n}\n\n// Callback when worker thread receives a message\nfunction workerThreadReceivedMessage(e)\n{\n\tvar msg = e.data;\n\n\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\tPapa.WORKER_ID = msg.workerId;\n\n\tif (typeof msg.input === 'string')\n\t{\n\t\tglobal.postMessage({\n\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\tfinished: true\n\t\t});\n\t}\n\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t{\n\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\tif (results)\n\t\t\tglobal.postMessage({\n\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\tresults: results,\n\t\t\t\tfinished: true\n\t\t\t});\n\t}\n}\n*/\n\n\nfunction notImplemented() {\n  throw new Error('Not implemented.');\n}\n/** Makes a deep copy of an array or object (mostly) */\n\n\nfunction copy(obj) {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  var cpy = Array.isArray(obj) ? [] : {};\n\n  for (var key in obj) cpy[key] = copy(obj[key]);\n\n  return cpy;\n}\n\nfunction bindFunction(f, self) {\n  return function () {\n    f.apply(self, arguments);\n  };\n}\n\nfunction isFunction(func) {\n  return typeof func === 'function';\n}","map":{"version":3,"sources":["/Users/idg08/Desktop/works/hospital/node_modules/@loaders.gl/csv/dist/esm/libs/papaparse.js"],"names":["global","self","window","IS_PAPA_WORKER","Papa","module","exports","parse","CsvToJson","unparse","JsonToCsv","RECORD_SEP","String","fromCharCode","UNIT_SEP","BYTE_ORDER_MARK","BAD_DELIMITERS","WORKERS_SUPPORTED","NODE_STREAM_INPUT","LocalChunkSize","RemoteChunkSize","DefaultDelimiter","Parser","ParserHandle","ChunkStreamer","StringStreamer","_input","_config","UserDefinedStreamer","dynamicTyping","isFunction","dynamicTypingFunction","transform","worker","w","newWorker","userStep","step","userChunk","chunk","userComplete","complete","userError","error","postMessage","input","config","workerId","id","streamer","stream","_quotes","_writeHeader","_delimiter","_newline","_quoteChar","_escapedQuote","_skipEmptyLines","_columns","unpackConfig","quoteCharRegex","RegExp","escapeRegExp","JSON","Array","isArray","length","serialize","objectKeys","data","fields","meta","Error","delimiter","filter","value","indexOf","quotes","skipEmptyLines","newline","quoteChar","header","columns","escapeChar","undefined","obj","keys","key","push","csv","hasHeader","dataKeyedByField","i","safe","row","maxCol","emptyLine","nullLine","Object","join","trim","line","c","cx","col","colIdx","str","constructor","Date","stringify","slice","toString","replace","needsQuotes","hasAny","charAt","substrings","_handle","_finished","_completed","_baseIndex","_partialLine","_rowCount","_start","_nextChunk","isFirstChunk","_completeResults","errors","replaceConfig","call","parseChunk","isFakeChunk","beforeFirstChunk","modifiedChunk","aggregate","results","paused","aborted","lastIndex","cursor","substring","finishedIncludingPreview","preview","WORKER_ID","finished","concat","_sendError","configCopy","copy","chunkSize","parseInt","remaining","s","size","substr","prototype","create","FLOAT","ISO_DATE","_stepCounter","_rowCounter","_parser","_paused","_aborted","_delimiterError","_fields","_results","needsHeaderRow","processResults","abort","baseIndex","ignoreLastRow","guessLineEndings","delimGuess","guessDelimiter","comments","delimitersToGuess","successful","bestDelimiter","parserConfig","pause","getCharIndex","resume","testEmptyLine","addError","splice","fillHeaderFields","applyHeaderAndDynamicTypingAndTransformation","addHeder","transformHeader","forEach","shouldApplyDynamicTyping","field","parseDynamic","test","parseFloat","processRow","rowSource","j","incrementBy","map","bestDelim","bestDelta","fieldCountPrevRow","delim","delta","avgFieldCount","emptyLinesCount","fieldCount","Math","abs","re","r","split","n","nAppearsFirst","numWithN","type","code","msg","message","string","fastMode","inputLen","delimLen","newlineLen","commentsLen","stepIsFunction","lastCursor","returnable","rows","pushRow","doStep","nextDelim","nextNewline","quoteSearch","index","finish","checkUpTo","min","spacesBetweenQuoteAndDelimiter","extraSpaces","spacesBetweenQuoteAndNewLine","saveRow","spaceLength","textBetweenClosingQuoteAndIndex","newCursor","stopped","isStep","linebreak","truncated","notImplemented","cpy","bindFunction","f","apply","arguments","func"],"mappings":"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","sourcesContent":["// This is a fork of papaparse\n// https://github.com/mholt/PapaParse\n/* @license\nPapa Parse\nv5.0.0-beta.0\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/\n// FORK SUMMARY:\n// - Adopt ES6 exports\n// - Implement new AsyncIteratorStreamer\n// - Remove non Async Iterator streamers (can all be handled by new streamer)\n// - Remove unused Worker support (loaders.gl worker system used instead)\n// - Remove unused jQuery plugin support\n\n/* eslint-disable */\n// @ts-nocheck\nvar global = (function() {\n  // alternative method, similar to `Function('return this')()`\n  // but without using `eval` (which is disabled when\n  // using Content Security Policy).\n\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  // When running tests none of the above have been defined\n  return {};\n})();\n\nvar IS_PAPA_WORKER = false;\n\nvar Papa = {};\nmodule.exports = Papa;\nPapa.parse = CsvToJson;\nPapa.unparse = JsonToCsv;\n\nPapa.RECORD_SEP = String.fromCharCode(30);\nPapa.UNIT_SEP = String.fromCharCode(31);\nPapa.BYTE_ORDER_MARK = '\\ufeff';\nPapa.BAD_DELIMITERS = ['\\r', '\\n', '\"', Papa.BYTE_ORDER_MARK];\nPapa.WORKERS_SUPPORTED = false; // !IS_WORKER && !!global.Worker;\nPapa.NODE_STREAM_INPUT = 1;\n\n// Configurable chunk sizes for local and remote files, respectively\nPapa.LocalChunkSize = 1024 * 1024 * 10; // 10 MB\nPapa.RemoteChunkSize = 1024 * 1024 * 5; // 5 MB\nPapa.DefaultDelimiter = ','; // Used if not specified and detection fails\n\n// Exposed for testing and development only\nPapa.Parser = Parser;\nPapa.ParserHandle = ParserHandle;\n\n// BEGIN FORK\nPapa.ChunkStreamer = ChunkStreamer;\nPapa.StringStreamer = StringStreamer;\n/*\nPapa.NetworkStreamer = NetworkStreamer;\nPapa.FileStreamer = FileStreamer;\nPapa.ReadableStreamStreamer = ReadableStreamStreamer;\nif (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n  Papa.DuplexStreamStreamer = DuplexStreamStreamer;\n}\n*/\n// END FORK\n\n// BEGIN FORK\n// Adds an argument to papa.parse\n// function CsvToJson(_input, _config)\nfunction CsvToJson(\n  _input,\n  _config,\n  UserDefinedStreamer // BEGIN FORK\n) {\n  _config = _config || {};\n  var dynamicTyping = _config.dynamicTyping || false;\n  if (isFunction(dynamicTyping)) {\n    _config.dynamicTypingFunction = dynamicTyping;\n    // Will be filled on first row call\n    dynamicTyping = {};\n  }\n  _config.dynamicTyping = dynamicTyping;\n\n  _config.transform = isFunction(_config.transform) ? _config.transform : false;\n\n  if (_config.worker && Papa.WORKERS_SUPPORTED) {\n    var w = newWorker();\n\n    w.userStep = _config.step;\n    w.userChunk = _config.chunk;\n    w.userComplete = _config.complete;\n    w.userError = _config.error;\n\n    _config.step = isFunction(_config.step);\n    _config.chunk = isFunction(_config.chunk);\n    _config.complete = isFunction(_config.complete);\n    _config.error = isFunction(_config.error);\n    delete _config.worker; // prevent infinite loop\n\n    w.postMessage({\n      input: _input,\n      config: _config,\n      workerId: w.id\n    });\n\n    return;\n  }\n\n  var streamer = null;\n  /*\n  if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n    // create a node Duplex stream for use\n    // with .pipe\n    streamer = new DuplexStreamStreamer(_config);\n    return streamer.getStream();\n  } else\n  */\n  if (typeof _input === 'string') {\n    // if (_config.download) streamer = new NetworkStreamer(_config);\n    // else\n    streamer = new StringStreamer(_config);\n  }\n  /*\n  else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on)) {\n    streamer = new ReadableStreamStreamer(_config);\n  } else if ((global.File && _input instanceof File) || _input instanceof Object)\n    // ...Safari. (see issue #106)\n    streamer = new FileStreamer(_config);\n  */\n\n  // BEGIN FORK\n  if (!streamer) {\n    streamer = new UserDefinedStreamer(_config);\n  }\n  // END FORK\n\n  return streamer.stream(_input);\n}\n\nfunction JsonToCsv(_input, _config) {\n  // Default configuration\n\n  /** whether to surround every datum with quotes */\n  var _quotes = false;\n\n  /** whether to write headers */\n  var _writeHeader = true;\n\n  /** delimiting character(s) */\n  var _delimiter = ',';\n\n  /** newline character(s) */\n  var _newline = '\\r\\n';\n\n  /** quote character */\n  var _quoteChar = '\"';\n\n  /** escaped quote character, either \"\" or <config.escapeChar>\" */\n  var _escapedQuote = _quoteChar + _quoteChar;\n\n  /** whether to skip empty lines */\n  var _skipEmptyLines = false;\n\n  /** the columns (keys) we expect when we unparse objects */\n  var _columns = null;\n\n  unpackConfig();\n\n  var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');\n\n  if (typeof _input === 'string') _input = JSON.parse(_input);\n\n  if (Array.isArray(_input)) {\n    if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);\n    else if (typeof _input[0] === 'object')\n      return serialize(_columns || objectKeys(_input[0]), _input, _skipEmptyLines);\n  } else if (typeof _input === 'object') {\n    if (typeof _input.data === 'string') _input.data = JSON.parse(_input.data);\n\n    if (Array.isArray(_input.data)) {\n      if (!_input.fields) _input.fields = _input.meta && _input.meta.fields;\n\n      if (!_input.fields)\n        _input.fields = Array.isArray(_input.data[0]) ? _input.fields : objectKeys(_input.data[0]);\n\n      if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== 'object')\n        _input.data = [_input.data]; // handles input like [1,2,3] or ['asdf']\n    }\n\n    return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);\n  }\n\n  // Default (any valid paths should return before this)\n  throw new Error('Unable to serialize unrecognized input');\n\n  function unpackConfig() {\n    if (typeof _config !== 'object') return;\n\n    if (\n      typeof _config.delimiter === 'string' &&\n      !Papa.BAD_DELIMITERS.filter(function(value) {\n        return _config.delimiter.indexOf(value) !== -1;\n      }).length\n    ) {\n      _delimiter = _config.delimiter;\n    }\n\n    if (typeof _config.quotes === 'boolean' || Array.isArray(_config.quotes))\n      _quotes = _config.quotes;\n\n    if (typeof _config.skipEmptyLines === 'boolean' || typeof _config.skipEmptyLines === 'string')\n      _skipEmptyLines = _config.skipEmptyLines;\n\n    if (typeof _config.newline === 'string') _newline = _config.newline;\n\n    if (typeof _config.quoteChar === 'string') _quoteChar = _config.quoteChar;\n\n    if (typeof _config.header === 'boolean') _writeHeader = _config.header;\n\n    if (Array.isArray(_config.columns)) {\n      if (_config.columns.length === 0) throw new Error('Option columns is empty');\n\n      _columns = _config.columns;\n    }\n\n    if (_config.escapeChar !== undefined) {\n      _escapedQuote = _config.escapeChar + _quoteChar;\n    }\n  }\n\n  /** Turns an object's keys into an array */\n  function objectKeys(obj) {\n    if (typeof obj !== 'object') return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    return keys;\n  }\n\n  /** The double for loop that iterates the data and writes out a CSV string including header row */\n  function serialize(fields, data, skipEmptyLines) {\n    var csv = '';\n\n    if (typeof fields === 'string') fields = JSON.parse(fields);\n    if (typeof data === 'string') data = JSON.parse(data);\n\n    var hasHeader = Array.isArray(fields) && fields.length > 0;\n    var dataKeyedByField = !Array.isArray(data[0]);\n\n    // If there a header row, write it first\n    if (hasHeader && _writeHeader) {\n      for (var i = 0; i < fields.length; i++) {\n        if (i > 0) csv += _delimiter;\n        csv += safe(fields[i], i);\n      }\n      if (data.length > 0) csv += _newline;\n    }\n\n    // Then write out the data\n    for (var row = 0; row < data.length; row++) {\n      var maxCol = hasHeader ? fields.length : data[row].length;\n\n      var emptyLine = false;\n      var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;\n      if (skipEmptyLines && !hasHeader) {\n        emptyLine =\n          skipEmptyLines === 'greedy'\n            ? data[row].join('').trim() === ''\n            : data[row].length === 1 && data[row][0].length === 0;\n      }\n      if (skipEmptyLines === 'greedy' && hasHeader) {\n        var line = [];\n        for (var c = 0; c < maxCol; c++) {\n          var cx = dataKeyedByField ? fields[c] : c;\n          line.push(data[row][cx]);\n        }\n        emptyLine = line.join('').trim() === '';\n      }\n      if (!emptyLine) {\n        for (var col = 0; col < maxCol; col++) {\n          if (col > 0 && !nullLine) csv += _delimiter;\n          var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n          csv += safe(data[row][colIdx], col);\n        }\n        if (row < data.length - 1 && (!skipEmptyLines || (maxCol > 0 && !nullLine))) {\n          csv += _newline;\n        }\n      }\n    }\n    return csv;\n  }\n\n  /** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n  function safe(str, col) {\n    if (typeof str === 'undefined' || str === null) return '';\n\n    if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);\n\n    str = str.toString().replace(quoteCharRegex, _escapedQuote);\n\n    var needsQuotes =\n      (typeof _quotes === 'boolean' && _quotes) ||\n      (Array.isArray(_quotes) && _quotes[col]) ||\n      hasAny(str, Papa.BAD_DELIMITERS) ||\n      str.indexOf(_delimiter) > -1 ||\n      str.charAt(0) === ' ' ||\n      str.charAt(str.length - 1) === ' ';\n\n    return needsQuotes ? _quoteChar + str + _quoteChar : str;\n  }\n\n  function hasAny(str, substrings) {\n    for (var i = 0; i < substrings.length; i++) if (str.indexOf(substrings[i]) > -1) return true;\n    return false;\n  }\n}\n\n/** ChunkStreamer is the base prototype for various streamer implementations. */\nfunction ChunkStreamer(config) {\n  this._handle = null;\n  this._finished = false;\n  this._completed = false;\n  this._input = null;\n  this._baseIndex = 0;\n  this._partialLine = '';\n  this._rowCount = 0;\n  this._start = 0;\n  this._nextChunk = null;\n  this.isFirstChunk = true;\n  this._completeResults = {\n    data: [],\n    errors: [],\n    meta: {}\n  };\n  replaceConfig.call(this, config);\n\n  this.parseChunk = function(chunk, isFakeChunk) {\n    // First chunk pre-processing\n    if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {\n      var modifiedChunk = this._config.beforeFirstChunk(chunk);\n      if (modifiedChunk !== undefined) chunk = modifiedChunk;\n    }\n    this.isFirstChunk = false;\n\n    // Rejoin the line we likely just split in two by chunking the file\n    var aggregate = this._partialLine + chunk;\n    this._partialLine = '';\n\n    var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\n    if (this._handle.paused() || this._handle.aborted()) return;\n\n    var lastIndex = results.meta.cursor;\n\n    if (!this._finished) {\n      this._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n      this._baseIndex = lastIndex;\n    }\n\n    if (results && results.data) this._rowCount += results.data.length;\n\n    var finishedIncludingPreview =\n      this._finished || (this._config.preview && this._rowCount >= this._config.preview);\n\n    if (IS_PAPA_WORKER) {\n      global.postMessage({\n        results: results,\n        workerId: Papa.WORKER_ID,\n        finished: finishedIncludingPreview\n      });\n    } else if (isFunction(this._config.chunk) && !isFakeChunk) {\n      this._config.chunk(results, this._handle);\n      if (this._handle.paused() || this._handle.aborted()) return;\n      results = undefined;\n      this._completeResults = undefined;\n    }\n\n    if (!this._config.step && !this._config.chunk) {\n      this._completeResults.data = this._completeResults.data.concat(results.data);\n      this._completeResults.errors = this._completeResults.errors.concat(results.errors);\n      this._completeResults.meta = results.meta;\n    }\n\n    if (\n      !this._completed &&\n      finishedIncludingPreview &&\n      isFunction(this._config.complete) &&\n      (!results || !results.meta.aborted)\n    ) {\n      this._config.complete(this._completeResults, this._input);\n      this._completed = true;\n    }\n\n    if (!finishedIncludingPreview && (!results || !results.meta.paused)) this._nextChunk();\n\n    return results;\n  };\n\n  this._sendError = function(error) {\n    if (isFunction(this._config.error)) this._config.error(error);\n    else if (IS_PAPA_WORKER && this._config.error) {\n      global.postMessage({\n        workerId: Papa.WORKER_ID,\n        error: error,\n        finished: false\n      });\n    }\n  };\n\n  function replaceConfig(config) {\n    // Deep-copy the config so we can edit it\n    var configCopy = copy(config);\n    configCopy.chunkSize = parseInt(configCopy.chunkSize); // parseInt VERY important so we don't concatenate strings!\n    if (!config.step && !config.chunk) configCopy.chunkSize = null; // disable Range header if not streaming; bad values break IIS - see issue #196\n    this._handle = new ParserHandle(configCopy);\n    this._handle.streamer = this;\n    this._config = configCopy; // persist the copy to the caller\n  }\n}\n\n/*\nfunction NetworkStreamer(config) {\n  config = config || {};\n  if (!config.chunkSize) config.chunkSize = Papa.RemoteChunkSize;\n  ChunkStreamer.call(this, config);\n\n  var xhr;\n\n  if (IS_WORKER) {\n    this._nextChunk = function() {\n      this._readChunk();\n      this._chunkLoaded();\n    };\n  } else {\n    this._nextChunk = function() {\n      this._readChunk();\n    };\n  }\n\n  this.stream = function(url) {\n    this._input = url;\n    this._nextChunk(); // Starts streaming\n  };\n\n  this._readChunk = function() {\n    if (this._finished) {\n      this._chunkLoaded();\n      return;\n    }\n\n    xhr = new XMLHttpRequest();\n\n    if (this._config.withCredentials) {\n      xhr.withCredentials = this._config.withCredentials;\n    }\n\n    if (!IS_WORKER) {\n      xhr.onload = bindFunction(this._chunkLoaded, this);\n      xhr.onerror = bindFunction(this._chunkError, this);\n    }\n\n    xhr.open('GET', this._input, !IS_WORKER);\n    // Headers can only be set when once the request state is OPENED\n    if (this._config.downloadRequestHeaders) {\n      var headers = this._config.downloadRequestHeaders;\n\n      for (var headerName in headers) {\n        xhr.setRequestHeader(headerName, headers[headerName]);\n      }\n    }\n\n    if (this._config.chunkSize) {\n      var end = this._start + this._config.chunkSize - 1; // minus one because byte range is inclusive\n      xhr.setRequestHeader('Range', 'bytes=' + this._start + '-' + end);\n    }\n\n    try {\n      xhr.send();\n    } catch (err) {\n      this._chunkError(err.message);\n    }\n\n    if (IS_WORKER && xhr.status === 0) this._chunkError();\n    else this._start += this._config.chunkSize;\n  };\n\n  this._chunkLoaded = function() {\n    if (xhr.readyState !== 4) return;\n\n    if (xhr.status < 200 || xhr.status >= 400) {\n      this._chunkError();\n      return;\n    }\n\n    this._finished = !this._config.chunkSize || this._start > getFileSize(xhr);\n    this.parseChunk(xhr.responseText);\n  };\n\n  this._chunkError = function(errorMessage) {\n    var errorText = xhr.statusText || errorMessage;\n    this._sendError(new Error(errorText));\n  };\n\n  function getFileSize(xhr) {\n    var contentRange = xhr.getResponseHeader('Content-Range');\n    if (contentRange === null) {\n      // no content range, then finish!\n      return -1;\n    }\n    return parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));\n  }\n}\nNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\nNetworkStreamer.prototype.constructor = NetworkStreamer;\n\nfunction FileStreamer(config) {\n  config = config || {};\n  if (!config.chunkSize) config.chunkSize = Papa.LocalChunkSize;\n  ChunkStreamer.call(this, config);\n\n  var reader, slice;\n\n  // FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n  // But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n  var usingAsyncReader = typeof FileReader !== 'undefined'; // Safari doesn't consider it a function - see issue #105\n\n  this.stream = function(file) {\n    this._input = file;\n    slice = file.slice || file.webkitSlice || file.mozSlice;\n\n    if (usingAsyncReader) {\n      reader = new FileReader(); // Preferred method of reading files, even in workers\n      reader.onload = bindFunction(this._chunkLoaded, this);\n      reader.onerror = bindFunction(this._chunkError, this);\n    } else reader = new FileReaderSync(); // Hack for running in a web worker in Firefox\n\n    this._nextChunk(); // Starts streaming\n  };\n\n  this._nextChunk = function() {\n    if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n      this._readChunk();\n  };\n\n  this._readChunk = function() {\n    var input = this._input;\n    if (this._config.chunkSize) {\n      var end = Math.min(this._start + this._config.chunkSize, this._input.size);\n      input = slice.call(input, this._start, end);\n    }\n    var txt = reader.readAsText(input, this._config.encoding);\n    if (!usingAsyncReader) this._chunkLoaded({target: {result: txt}}); // mimic the async signature\n  };\n\n  this._chunkLoaded = function(event) {\n    // Very important to increment start each time before handling results\n    this._start += this._config.chunkSize;\n    this._finished = !this._config.chunkSize || this._start >= this._input.size;\n    this.parseChunk(event.target.result);\n  };\n\n  this._chunkError = function() {\n    this._sendError(reader.error);\n  };\n}\nFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\nFileStreamer.prototype.constructor = FileStreamer;\n*/\n\nfunction StringStreamer(config) {\n  config = config || {};\n  ChunkStreamer.call(this, config);\n\n  var remaining;\n  this.stream = function(s) {\n    remaining = s;\n    return this._nextChunk();\n  };\n  this._nextChunk = function() {\n    if (this._finished) return;\n    var size = this._config.chunkSize;\n    var chunk = size ? remaining.substr(0, size) : remaining;\n    remaining = size ? remaining.substr(size) : '';\n    this._finished = !remaining;\n    return this.parseChunk(chunk);\n  };\n}\nStringStreamer.prototype = Object.create(StringStreamer.prototype);\nStringStreamer.prototype.constructor = StringStreamer;\n\n/*\nfunction ReadableStreamStreamer(config) {\n  config = config || {};\n\n  ChunkStreamer.call(this, config);\n\n  var queue = [];\n  var parseOnData = true;\n  var streamHasEnded = false;\n\n  this.pause = function() {\n    ChunkStreamer.prototype.pause.apply(this, arguments);\n    this._input.pause();\n  };\n\n  this.resume = function() {\n    ChunkStreamer.prototype.resume.apply(this, arguments);\n    this._input.resume();\n  };\n\n  this.stream = function(stream) {\n    this._input = stream;\n\n    this._input.on('data', this._streamData);\n    this._input.on('end', this._streamEnd);\n    this._input.on('error', this._streamError);\n  };\n\n  this._checkIsFinished = function() {\n    if (streamHasEnded && queue.length === 1) {\n      this._finished = true;\n    }\n  };\n\n  this._nextChunk = function() {\n    this._checkIsFinished();\n    if (queue.length) {\n      this.parseChunk(queue.shift());\n    } else {\n      parseOnData = true;\n    }\n  };\n\n  this._streamData = bindFunction(function(chunk) {\n    try {\n      queue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));\n\n      if (parseOnData) {\n        parseOnData = false;\n        this._checkIsFinished();\n        this.parseChunk(queue.shift());\n      }\n    } catch (error) {\n      this._streamError(error);\n    }\n  }, this);\n\n  this._streamError = bindFunction(function(error) {\n    this._streamCleanUp();\n    this._sendError(error);\n  }, this);\n\n  this._streamEnd = bindFunction(function() {\n    this._streamCleanUp();\n    streamHasEnded = true;\n    this._streamData('');\n  }, this);\n\n  this._streamCleanUp = bindFunction(function() {\n    this._input.removeListener('data', this._streamData);\n    this._input.removeListener('end', this._streamEnd);\n    this._input.removeListener('error', this._streamError);\n  }, this);\n}\nReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\nReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n\nfunction DuplexStreamStreamer(_config) {\n  var Duplex = require('stream').Duplex;\n  var config = copy(_config);\n  var parseOnWrite = true;\n  var writeStreamHasFinished = false;\n  var parseCallbackQueue = [];\n  var stream = null;\n\n  this._onCsvData = function(results) {\n    var data = results.data;\n    if (!stream.push(data) && !this._handle.paused()) {\n      // the writeable consumer buffer has filled up\n      // so we need to pause until more items\n      // can be processed\n      this._handle.pause();\n    }\n  };\n\n  this._onCsvComplete = function() {\n    // node will finish the read stream when\n    // null is pushed\n    stream.push(null);\n  };\n\n  config.step = bindFunction(this._onCsvData, this);\n  config.complete = bindFunction(this._onCsvComplete, this);\n  ChunkStreamer.call(this, config);\n\n  this._nextChunk = function() {\n    if (writeStreamHasFinished && parseCallbackQueue.length === 1) {\n      this._finished = true;\n    }\n    if (parseCallbackQueue.length) {\n      parseCallbackQueue.shift()();\n    } else {\n      parseOnWrite = true;\n    }\n  };\n\n  this._addToParseQueue = function(chunk, callback) {\n    // add to queue so that we can indicate\n    // completion via callback\n    // node will automatically pause the incoming stream\n    // when too many items have been added without their\n    // callback being invoked\n    parseCallbackQueue.push(\n      bindFunction(function() {\n        this.parseChunk(typeof chunk === 'string' ? chunk : chunk.toString(config.encoding));\n        if (isFunction(callback)) {\n          return callback();\n        }\n      }, this)\n    );\n    if (parseOnWrite) {\n      parseOnWrite = false;\n      this._nextChunk();\n    }\n  };\n\n  this._onRead = function() {\n    if (this._handle.paused()) {\n      // the writeable consumer can handle more data\n      // so resume the chunk parsing\n      this._handle.resume();\n    }\n  };\n\n  this._onWrite = function(chunk, encoding, callback) {\n    this._addToParseQueue(chunk, callback);\n  };\n\n  this._onWriteComplete = function() {\n    writeStreamHasFinished = true;\n    // have to write empty string\n    // so parser knows its done\n    this._addToParseQueue('');\n  };\n\n  this.getStream = function() {\n    return stream;\n  };\n  stream = new Duplex({\n    readableObjectMode: true,\n    decodeStrings: false,\n    read: bindFunction(this._onRead, this),\n    write: bindFunction(this._onWrite, this)\n  });\n  stream.once('finish', bindFunction(this._onWriteComplete, this));\n}\nif (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n  DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n  DuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;\n}\n*/\n\n// Use one ParserHandle per entire CSV file or string\nfunction ParserHandle(_config) {\n  // One goal is to minimize the use of regular expressions...\n  var FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n  var ISO_DATE = /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/;\n\n  var self = this;\n  var _stepCounter = 0; // Number of times step was called (number of rows parsed)\n  var _rowCounter = 0; // Number of rows that have been parsed so far\n  var _input; // The input being parsed\n  var _parser; // The core parser being used\n  var _paused = false; // Whether we are paused or not\n  var _aborted = false; // Whether the parser has aborted or not\n  var _delimiterError; // Temporary state between delimiter detection and processing results\n  var _fields = []; // Fields are from the header row of the input, if there is one\n  var _results = {\n    // The last results returned from the parser\n    data: [],\n    errors: [],\n    meta: {}\n  };\n\n  if (isFunction(_config.step)) {\n    var userStep = _config.step;\n    _config.step = function(results) {\n      _results = results;\n\n      if (needsHeaderRow()) processResults();\n      // only call user's step function after header row\n      else {\n        processResults();\n\n        // It's possbile that this line was empty and there's no row here after all\n        if (_results.data.length === 0) return;\n\n        _stepCounter += results.data.length;\n        if (_config.preview && _stepCounter > _config.preview) _parser.abort();\n        else userStep(_results, self);\n      }\n    };\n  }\n\n  /**\n   * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n   * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n   * when an input comes in multiple chunks, like from a file.\n   */\n  this.parse = function(input, baseIndex, ignoreLastRow) {\n    var quoteChar = _config.quoteChar || '\"';\n    if (!_config.newline) _config.newline = guessLineEndings(input, quoteChar);\n\n    _delimiterError = false;\n    if (!_config.delimiter) {\n      var delimGuess = guessDelimiter(\n        input,\n        _config.newline,\n        _config.skipEmptyLines,\n        _config.comments,\n        _config.delimitersToGuess\n      );\n      if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;\n      else {\n        _delimiterError = true; // add error after parsing (otherwise it would be overwritten)\n        _config.delimiter = Papa.DefaultDelimiter;\n      }\n      _results.meta.delimiter = _config.delimiter;\n    } else if (isFunction(_config.delimiter)) {\n      _config.delimiter = _config.delimiter(input);\n      _results.meta.delimiter = _config.delimiter;\n    }\n\n    var parserConfig = copy(_config);\n    if (_config.preview && _config.header) parserConfig.preview++; // to compensate for header row\n\n    _input = input;\n    _parser = new Parser(parserConfig);\n    _results = _parser.parse(_input, baseIndex, ignoreLastRow);\n    processResults();\n    return _paused ? {meta: {paused: true}} : _results || {meta: {paused: false}};\n  };\n\n  this.paused = function() {\n    return _paused;\n  };\n\n  this.pause = function() {\n    _paused = true;\n    _parser.abort();\n    _input = _input.substr(_parser.getCharIndex());\n  };\n\n  this.resume = function() {\n    _paused = false;\n    self.streamer.parseChunk(_input, true);\n  };\n\n  this.aborted = function() {\n    return _aborted;\n  };\n\n  this.abort = function() {\n    _aborted = true;\n    _parser.abort();\n    _results.meta.aborted = true;\n    if (isFunction(_config.complete)) _config.complete(_results);\n    _input = '';\n  };\n\n  function testEmptyLine(s) {\n    return _config.skipEmptyLines === 'greedy'\n      ? s.join('').trim() === ''\n      : s.length === 1 && s[0].length === 0;\n  }\n\n  function processResults() {\n    if (_results && _delimiterError) {\n      addError(\n        'Delimiter',\n        'UndetectableDelimiter',\n        \"Unable to auto-detect delimiting character; defaulted to '\" + Papa.DefaultDelimiter + \"'\"\n      );\n      _delimiterError = false;\n    }\n\n    if (_config.skipEmptyLines) {\n      for (var i = 0; i < _results.data.length; i++)\n        if (testEmptyLine(_results.data[i])) _results.data.splice(i--, 1);\n    }\n\n    if (needsHeaderRow()) fillHeaderFields();\n\n    return applyHeaderAndDynamicTypingAndTransformation();\n  }\n\n  function needsHeaderRow() {\n    return _config.header && _fields.length === 0;\n  }\n\n  function fillHeaderFields() {\n    if (!_results) return;\n\n    function addHeder(header) {\n      if (isFunction(_config.transformHeader)) header = _config.transformHeader(header);\n\n      _fields.push(header);\n    }\n\n    if (Array.isArray(_results.data[0])) {\n      for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)\n        _results.data[i].forEach(addHeder);\n\n      _results.data.splice(0, 1);\n    }\n    // if _results.data[0] is not an array, we are in a step where _results.data is the row.\n    else _results.data.forEach(addHeder);\n  }\n\n  function shouldApplyDynamicTyping(field) {\n    // Cache function values to avoid calling it for each row\n    if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n      _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n    }\n    return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;\n  }\n\n  function parseDynamic(field, value) {\n    if (shouldApplyDynamicTyping(field)) {\n      if (value === 'true' || value === 'TRUE') return true;\n      else if (value === 'false' || value === 'FALSE') return false;\n      else if (FLOAT.test(value)) return parseFloat(value);\n      else if (ISO_DATE.test(value)) return new Date(value);\n      else return value === '' ? null : value;\n    }\n    return value;\n  }\n\n  function applyHeaderAndDynamicTypingAndTransformation() {\n    if (!_results || (!_config.header && !_config.dynamicTyping && !_config.transform))\n      return _results;\n\n    function processRow(rowSource, i) {\n      var row = _config.header ? {} : [];\n\n      var j;\n      for (j = 0; j < rowSource.length; j++) {\n        var field = j;\n        var value = rowSource[j];\n\n        if (_config.header) field = j >= _fields.length ? '__parsed_extra' : _fields[j];\n\n        if (_config.transform) value = _config.transform(value, field);\n\n        value = parseDynamic(field, value);\n\n        if (field === '__parsed_extra') {\n          row[field] = row[field] || [];\n          row[field].push(value);\n        } else row[field] = value;\n      }\n\n      if (_config.header) {\n        if (j > _fields.length)\n          addError(\n            'FieldMismatch',\n            'TooManyFields',\n            'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j,\n            _rowCounter + i\n          );\n        else if (j < _fields.length)\n          addError(\n            'FieldMismatch',\n            'TooFewFields',\n            'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j,\n            _rowCounter + i\n          );\n      }\n\n      return row;\n    }\n\n    var incrementBy = 1;\n    if (!_results.data[0] || Array.isArray(_results.data[0])) {\n      _results.data = _results.data.map(processRow);\n      incrementBy = _results.data.length;\n    } else _results.data = processRow(_results.data, 0);\n\n    if (_config.header && _results.meta) _results.meta.fields = _fields;\n\n    _rowCounter += incrementBy;\n    return _results;\n  }\n\n  function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {\n    var bestDelim, bestDelta, fieldCountPrevRow;\n\n    delimitersToGuess = delimitersToGuess || [',', '\\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];\n\n    for (var i = 0; i < delimitersToGuess.length; i++) {\n      var delim = delimitersToGuess[i];\n      var delta = 0,\n        avgFieldCount = 0,\n        emptyLinesCount = 0;\n      fieldCountPrevRow = undefined;\n\n      var preview = new Parser({\n        comments: comments,\n        delimiter: delim,\n        newline: newline,\n        preview: 10\n      }).parse(input);\n\n      for (var j = 0; j < preview.data.length; j++) {\n        if (skipEmptyLines && testEmptyLine(preview.data[j])) {\n          emptyLinesCount++;\n          continue;\n        }\n        var fieldCount = preview.data[j].length;\n        avgFieldCount += fieldCount;\n\n        if (typeof fieldCountPrevRow === 'undefined') {\n          fieldCountPrevRow = 0;\n          continue;\n        } else if (fieldCount > 1) {\n          delta += Math.abs(fieldCount - fieldCountPrevRow);\n          fieldCountPrevRow = fieldCount;\n        }\n      }\n\n      if (preview.data.length > 0) avgFieldCount /= preview.data.length - emptyLinesCount;\n\n      if ((typeof bestDelta === 'undefined' || delta > bestDelta) && avgFieldCount > 1.99) {\n        bestDelta = delta;\n        bestDelim = delim;\n      }\n    }\n\n    _config.delimiter = bestDelim;\n\n    return {\n      successful: !!bestDelim,\n      bestDelimiter: bestDelim\n    };\n  }\n\n  function guessLineEndings(input, quoteChar) {\n    input = input.substr(0, 1024 * 1024); // max length 1 MB\n    // Replace all the text inside quotes\n    var re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');\n    input = input.replace(re, '');\n\n    var r = input.split('\\r');\n\n    var n = input.split('\\n');\n\n    var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;\n\n    if (r.length === 1 || nAppearsFirst) return '\\n';\n\n    var numWithN = 0;\n    for (var i = 0; i < r.length; i++) {\n      if (r[i][0] === '\\n') numWithN++;\n    }\n\n    return numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n  }\n\n  function addError(type, code, msg, row) {\n    _results.errors.push({\n      type: type,\n      code: code,\n      message: msg,\n      row: row\n    });\n  }\n}\n\n/** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\n/** The core parser implements speedy and correct CSV parsing */\nfunction Parser(config) {\n  // Unpack the config object\n  config = config || {};\n  var delim = config.delimiter;\n  var newline = config.newline;\n  var comments = config.comments;\n  var step = config.step;\n  var preview = config.preview;\n  var fastMode = config.fastMode;\n  var quoteChar;\n  /** Allows for no quoteChar by setting quoteChar to undefined in config */\n  if (config.quoteChar === undefined) {\n    quoteChar = '\"';\n  } else {\n    quoteChar = config.quoteChar;\n  }\n  var escapeChar = quoteChar;\n  if (config.escapeChar !== undefined) {\n    escapeChar = config.escapeChar;\n  }\n\n  // Delimiter must be valid\n  if (typeof delim !== 'string' || Papa.BAD_DELIMITERS.indexOf(delim) > -1) delim = ',';\n\n  // Comment character must be valid\n  if (comments === delim) throw new Error('Comment character same as delimiter');\n  else if (comments === true) comments = '#';\n  else if (typeof comments !== 'string' || Papa.BAD_DELIMITERS.indexOf(comments) > -1)\n    comments = false;\n\n  // Newline must be valid: \\r, \\n, or \\r\\n\n  if (newline !== '\\n' && newline !== '\\r' && newline !== '\\r\\n') newline = '\\n';\n\n  // We're gonna need these at the Parser scope\n  var cursor = 0;\n  var aborted = false;\n\n  this.parse = function(input, baseIndex, ignoreLastRow) {\n    // For some reason, in Chrome, this speeds things up (!?)\n    if (typeof input !== 'string') throw new Error('Input must be a string');\n\n    // We don't need to compute some of these every time parse() is called,\n    // but having them in a more local scope seems to perform better\n    var inputLen = input.length,\n      delimLen = delim.length,\n      newlineLen = newline.length,\n      commentsLen = comments.length;\n    var stepIsFunction = isFunction(step);\n\n    // Establish starting state\n    cursor = 0;\n    var data = [],\n      errors = [],\n      row = [],\n      lastCursor = 0;\n\n    if (!input) return returnable();\n\n    if (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1)) {\n      var rows = input.split(newline);\n      for (var i = 0; i < rows.length; i++) {\n        row = rows[i];\n        cursor += row.length;\n        if (i !== rows.length - 1) cursor += newline.length;\n        else if (ignoreLastRow) return returnable();\n        if (comments && row.substr(0, commentsLen) === comments) continue;\n        if (stepIsFunction) {\n          data = [];\n          pushRow(row.split(delim));\n          doStep();\n          if (aborted) return returnable();\n        } else pushRow(row.split(delim));\n        if (preview && i >= preview) {\n          data = data.slice(0, preview);\n          return returnable(true);\n        }\n      }\n      return returnable();\n    }\n\n    var nextDelim = input.indexOf(delim, cursor);\n    var nextNewline = input.indexOf(newline, cursor);\n    var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');\n    var quoteSearch;\n\n    // Parser loop\n    for (;;) {\n      // Field has opening quote\n      if (input[cursor] === quoteChar) {\n        // Start our search for the closing quote where the cursor is\n        quoteSearch = cursor;\n\n        // Skip the opening quote\n        cursor++;\n\n        for (;;) {\n          // Find closing quote\n          quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);\n\n          //No other quotes are found - no other delimiters\n          if (quoteSearch === -1) {\n            if (!ignoreLastRow) {\n              // No closing quote... what a pity\n              errors.push({\n                type: 'Quotes',\n                code: 'MissingQuotes',\n                message: 'Quoted field unterminated',\n                row: data.length, // row has yet to be inserted\n                index: cursor\n              });\n            }\n            return finish();\n          }\n\n          // Closing quote at EOF\n          if (quoteSearch === inputLen - 1) {\n            var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n            return finish(value);\n          }\n\n          // If this quote is escaped, it's part of the data; skip it\n          // If the quote character is the escape character, then check if the next character is the escape character\n          if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {\n            quoteSearch++;\n            continue;\n          }\n\n          // If the quote character is not the escape character, then check if the previous character was the escape character\n          if (\n            quoteChar !== escapeChar &&\n            quoteSearch !== 0 &&\n            input[quoteSearch - 1] === escapeChar\n          ) {\n            continue;\n          }\n\n          // Check up to nextDelim or nextNewline, whichever is closest\n          var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);\n          var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);\n\n          // Closing quote followed by delimiter or 'unnecessary spaces + delimiter'\n          if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim) {\n            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n            cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;\n            nextDelim = input.indexOf(delim, cursor);\n            nextNewline = input.indexOf(newline, cursor);\n            break;\n          }\n\n          var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);\n\n          // Closing quote followed by newline or 'unnecessary spaces + newLine'\n          if (\n            input.substr(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, newlineLen) === newline\n          ) {\n            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n            saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);\n            nextDelim = input.indexOf(delim, cursor); // because we may have skipped the nextDelim in the quoted field\n\n            if (stepIsFunction) {\n              doStep();\n              if (aborted) return returnable();\n            }\n\n            if (preview && data.length >= preview) return returnable(true);\n\n            break;\n          }\n\n          // Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string\n          errors.push({\n            type: 'Quotes',\n            code: 'InvalidQuotes',\n            message: 'Trailing quote on quoted field is malformed',\n            row: data.length, // row has yet to be inserted\n            index: cursor\n          });\n\n          quoteSearch++;\n          continue;\n        }\n\n        continue;\n      }\n\n      // Comment found at start of new line\n      if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments) {\n        if (nextNewline === -1)\n          // Comment ends at EOF\n          return returnable();\n        cursor = nextNewline + newlineLen;\n        nextNewline = input.indexOf(newline, cursor);\n        nextDelim = input.indexOf(delim, cursor);\n        continue;\n      }\n\n      // Next delimiter comes before next newline, so we've reached end of field\n      if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {\n        row.push(input.substring(cursor, nextDelim));\n        cursor = nextDelim + delimLen;\n        nextDelim = input.indexOf(delim, cursor);\n        continue;\n      }\n\n      // End of row\n      if (nextNewline !== -1) {\n        row.push(input.substring(cursor, nextNewline));\n        saveRow(nextNewline + newlineLen);\n\n        if (stepIsFunction) {\n          doStep();\n          if (aborted) return returnable();\n        }\n\n        if (preview && data.length >= preview) return returnable(true);\n\n        continue;\n      }\n\n      break;\n    }\n\n    return finish();\n\n    function pushRow(row) {\n      data.push(row);\n      lastCursor = cursor;\n    }\n\n    /**\n     * checks if there are extra spaces after closing quote and given index without any text\n     * if Yes, returns the number of spaces\n     */\n    function extraSpaces(index) {\n      var spaceLength = 0;\n      if (index !== -1) {\n        var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);\n        if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {\n          spaceLength = textBetweenClosingQuoteAndIndex.length;\n        }\n      }\n      return spaceLength;\n    }\n\n    /**\n     * Appends the remaining input from cursor to the end into\n     * row, saves the row, calls step, and returns the results.\n     */\n    function finish(value) {\n      if (ignoreLastRow) return returnable();\n      if (typeof value === 'undefined') value = input.substr(cursor);\n      row.push(value);\n      cursor = inputLen; // important in case parsing is paused\n      pushRow(row);\n      if (stepIsFunction) doStep();\n      return returnable();\n    }\n\n    /**\n     * Appends the current row to the results. It sets the cursor\n     * to newCursor and finds the nextNewline. The caller should\n     * take care to execute user's step function and check for\n     * preview and end parsing if necessary.\n     */\n    function saveRow(newCursor) {\n      cursor = newCursor;\n      pushRow(row);\n      row = [];\n      nextNewline = input.indexOf(newline, cursor);\n    }\n\n    /** Returns an object with the results, errors, and meta. */\n    function returnable(stopped, step) {\n      var isStep = step || false;\n      return {\n        data: isStep ? data[0] : data,\n        errors: errors,\n        meta: {\n          delimiter: delim,\n          linebreak: newline,\n          aborted: aborted,\n          truncated: !!stopped,\n          cursor: lastCursor + (baseIndex || 0)\n        }\n      };\n    }\n\n    /** Executes the user's step function and resets data & errors. */\n    function doStep() {\n      step(returnable(undefined, true));\n      data = [];\n      errors = [];\n    }\n  };\n\n  /** Sets the abort flag */\n  this.abort = function() {\n    aborted = true;\n  };\n\n  /** Gets the cursor position */\n  this.getCharIndex = function() {\n    return cursor;\n  };\n}\n\n/*\nfunction getWorkerBlob() {\n\tvar URL = global.URL || global.webkitURL || null;\n\tvar code = moduleFactory.toString();\n\treturn Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob(['(', code, ')();'], {type: 'text/javascript'})));\n}\n\nvar IS_WORKER = !global.document && !!global.postMessage,\n\tIS_PAPA_WORKER = IS_WORKER && /blob:/i.test((global.location || {}).protocol);\nvar workers = {}, workerIdCounter = 0;\n\nfunction newWorker()\n{\n\tif (!Papa.WORKERS_SUPPORTED)\n\t\treturn false;\n\n\tvar workerUrl = getWorkerBlob();\n\tvar w = new global.Worker(workerUrl);\n\tw.onmessage = mainThreadReceivedMessage;\n\tw.id = workerIdCounter++;\n\tworkers[w.id] = w;\n\treturn w;\n}\n\n// Callback when main thread receives a message\nfunction mainThreadReceivedMessage(e)\n{\n\tvar msg = e.data;\n\tvar worker = workers[msg.workerId];\n\tvar aborted = false;\n\n\tif (msg.error)\n\t\tworker.userError(msg.error, msg.file);\n\telse if (msg.results && msg.results.data)\n\t{\n\t\tvar abort = function() {\n\t\t\taborted = true;\n\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t};\n\n\t\tvar handle = {\n\t\t\tabort: abort,\n\t\t\tpause: notImplemented,\n\t\t\tresume: notImplemented\n\t\t};\n\n\t\tif (isFunction(worker.userStep))\n\t\t{\n\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t{\n\t\t\t\tworker.userStep({\n\t\t\t\t\tdata: msg.results.data[i],\n\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t}, handle);\n\t\t\t\tif (aborted)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t}\n\t\telse if (isFunction(worker.userChunk))\n\t\t{\n\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\tdelete msg.results;\n\t\t}\n\t}\n\n\tif (msg.finished && !aborted)\n\t\tcompleteWorker(msg.workerId, msg.results);\n}\n\nfunction completeWorker(workerId, results) {\n\tvar worker = workers[workerId];\n\tif (isFunction(worker.userComplete))\n\t\tworker.userComplete(results);\n\tworker.terminate();\n\tdelete workers[workerId];\n}\n\n// Callback when worker thread receives a message\nfunction workerThreadReceivedMessage(e)\n{\n\tvar msg = e.data;\n\n\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\tPapa.WORKER_ID = msg.workerId;\n\n\tif (typeof msg.input === 'string')\n\t{\n\t\tglobal.postMessage({\n\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\tfinished: true\n\t\t});\n\t}\n\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t{\n\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\tif (results)\n\t\t\tglobal.postMessage({\n\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\tresults: results,\n\t\t\t\tfinished: true\n\t\t\t});\n\t}\n}\n*/\n\nfunction notImplemented() {\n  throw new Error('Not implemented.');\n}\n\n/** Makes a deep copy of an array or object (mostly) */\nfunction copy(obj) {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  var cpy = Array.isArray(obj) ? [] : {};\n  for (var key in obj) cpy[key] = copy(obj[key]);\n  return cpy;\n}\n\nfunction bindFunction(f, self) {\n  return function() {\n    f.apply(self, arguments);\n  };\n}\n\nfunction isFunction(func) {\n  return typeof func === 'function';\n}\n"]},"metadata":{},"sourceType":"script"}