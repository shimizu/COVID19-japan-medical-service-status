{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { AsyncQueue, TableBatchBuilder, RowTableBatch } from '@loaders.gl/tables';\nimport Papa from './libs/papaparse';\nimport AsyncIteratorStreamer from './lib/async-iterator-streamer';\nvar VERSION = typeof \"2.1.6\" !== 'undefined' ? \"2.1.6\" : 'latest';\nvar CSVLoader = {\n  id: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv'],\n  mimeType: 'text/csv',\n  category: 'table',\n  parse: function () {\n    var _parse = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(arrayBuffer, options) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", parseCSVSync(new TextDecoder().decode(arrayBuffer), options));\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function parse(_x, _x2) {\n      return _parse.apply(this, arguments);\n    }\n\n    return parse;\n  }(),\n  parseTextSync: parseCSVSync,\n  parseInBatches: parseCSVInBatches,\n  testText: null,\n  options: {\n    csv: {\n      TableBatch: RowTableBatch,\n      batchSize: 10\n    }\n  }\n};\nexport default CSVLoader;\n\nfunction parseCSVSync(csvText, options) {\n  options = _objectSpread({}, CSVLoader.options, {}, options);\n  options.csv = _objectSpread({}, CSVLoader.options.csv, {}, options.csv);\n\n  var config = _objectSpread({\n    header: hasHeader(csvText, options),\n    dynamicTyping: true\n  }, options.csv, {\n    download: false,\n    error: function error(e) {\n      throw new Error(e);\n    }\n  });\n\n  var result = Papa.parse(csvText, config);\n  return result.data;\n}\n\nfunction parseCSVInBatches(asyncIterator, options) {\n  options = _objectSpread({}, CSVLoader.options, {}, options);\n  options.csv = _objectSpread({}, CSVLoader.options.csv, {}, options.csv);\n  var batchSize = options.csv.batchSize;\n  var TableBatchType = options.csv.TableBatch;\n  var asyncQueue = new AsyncQueue();\n  var isFirstRow = true;\n  var headerRow = null;\n  var tableBatchBuilder = null;\n  var schema = null;\n  var config = {\n    download: false,\n    dynamicTyping: true,\n    header: false,\n    step: function step(results, parser) {\n      var row = results.data;\n\n      if (isFirstRow && !headerRow) {\n        var header = options.header === undefined ? isHeaderRow(row) : options.header;\n\n        if (header) {\n          headerRow = row;\n          return;\n        }\n      }\n\n      if (isFirstRow) {\n        isFirstRow = false;\n        schema = deduceSchema(row, headerRow);\n      }\n\n      tableBatchBuilder = tableBatchBuilder || new TableBatchBuilder(TableBatchType, schema, batchSize);\n      tableBatchBuilder.addRow(row);\n\n      if (tableBatchBuilder.isFull()) {\n        asyncQueue.enqueue(tableBatchBuilder.getNormalizedBatch());\n      }\n    },\n    complete: function complete(results, file) {\n      var batch = tableBatchBuilder.getNormalizedBatch();\n\n      if (batch) {\n        asyncQueue.enqueue(batch);\n      }\n\n      asyncQueue.close();\n    }\n  };\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n  return asyncQueue;\n}\n\nfunction isHeaderRow(row) {\n  return row.every(function (value) {\n    return typeof value === 'string';\n  });\n}\n\nfunction hasHeader(csvText, options) {\n  if ('header' in options) {\n    return options.header;\n  }\n\n  var header = false;\n  Papa.parse(csvText, {\n    download: false,\n    dynamicTyping: true,\n    step: function step(results, parser) {\n      var row = results.data;\n      header = isHeaderRow(row);\n      parser.abort();\n    }\n  });\n  return header;\n}\n\nfunction deduceSchema(row, headerRow) {\n  var schema = headerRow ? {} : [];\n\n  for (var i = 0; i < row.length; i++) {\n    var columnName = headerRow && headerRow[i] || i;\n    var value = row[i];\n\n    switch (_typeof(value)) {\n      case 'number':\n      case 'boolean':\n        schema[columnName] = {\n          name: String(columnName),\n          index: i,\n          type: Float32Array\n        };\n        break;\n\n      case 'string':\n      default:\n        schema[columnName] = {\n          name: String(columnName),\n          index: i,\n          type: Array\n        };\n    }\n  }\n\n  return schema;\n}","map":{"version":3,"sources":["../../src/csv-loader.js"],"names":["VERSION","CSVLoader","id","name","version","extensions","mimeType","category","parse","parseCSVSync","parseTextSync","parseInBatches","testText","options","csv","TableBatch","batchSize","config","header","hasHeader","dynamicTyping","download","error","result","Papa","TableBatchType","asyncQueue","isFirstRow","headerRow","tableBatchBuilder","schema","step","row","results","isHeaderRow","deduceSchema","complete","batch","parser","i","columnName","value","String","index","type","Float32Array","Array"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,SAAA,UAAA,EAAA,iBAAA,EAAA,aAAA,QAAA,oBAAA;AACA,OAAA,IAAA,MAAA,kBAAA;AACA,OAAA,qBAAA,MAAA,+BAAA;AAGA,IAAMA,OAAO,GAAG,OAAA,OAAA,KAAA,WAAA,GAAA,OAAA,GAAhB,QAAA;AAEA,IAAMC,SAAS,GAAG;AAChBC,EAAAA,EAAE,EADc,KAAA;AAEhBC,EAAAA,IAAI,EAFY,KAAA;AAGhBC,EAAAA,OAAO,EAHS,OAAA;AAIhBC,EAAAA,UAAU,EAAE,CAJI,KAIJ,CAJI;AAKhBC,EAAAA,QAAQ,EALQ,UAAA;AAMhBC,EAAAA,QAAQ,EANQ,OAAA;AAOhBC,EAAAA,KAAK,EAAA,YAAA;AAAA,QAAA,MAAA,GAAA,iBAAA,CAAA,mBAAA,CAAA,IAAA,CAAE,SAAA,OAAA,CAAA,WAAA,EAAA,OAAA,EAAA;AAAA,aAAA,mBAAA,CAAA,IAAA,CAAA,SAAA,QAAA,CAAA,QAAA,EAAA;AAAA,eAAA,CAAA,EAAA;AAAA,kBAAA,QAAA,CAAA,IAAA,GAAA,QAAA,CAAA,IAAA;AAAA,iBAAA,CAAA;AAAA,qBAAA,QAAA,CAAA,MAAA,CAAA,QAAA,EACLC,YAAY,CAAC,IAAA,WAAA,GAAA,MAAA,CAAD,WAAC,CAAD,EADP,OACO,CADP,CAAA;;AAAA,iBAAA,CAAA;AAAA,iBAAA,KAAA;AAAA,qBAAA,QAAA,CAAA,IAAA,EAAA;AAAA;AAAA;AAAA,OAAA,EAAA,OAAA,CAAA;AAAF,KAAA,CAAA,CAAA;;AAAA,aAAA,KAAA,CAAA,EAAA,EAAA,GAAA,EAAA;AAAA,aAAA,MAAA,CAAA,KAAA,CAAA,IAAA,EAAA,SAAA,CAAA;AAAA;;AAAA,WAAA,KAAA;AAPW,GAOX,EAPW;AAShBC,EAAAA,aAAa,EATG,YAAA;AAUhBC,EAAAA,cAAc,EAVE,iBAAA;AAWhBC,EAAAA,QAAQ,EAXQ,IAAA;AAYhBC,EAAAA,OAAO,EAAE;AACPC,IAAAA,GAAG,EAAE;AACHC,MAAAA,UAAU,EADP,aAAA;AAEHC,MAAAA,SAAS,EAAE;AAFR;AADE;AAZO,CAAlB;AAoBA,eAAA,SAAA;;AAEA,SAAA,YAAA,CAAA,OAAA,EAAA,OAAA,EAAwC;AAEtCH,EAAAA,OAAO,GAAA,aAAA,CAAA,EAAA,EAAOZ,SAAS,CAAhB,OAAA,EAAA,EAAA,EAAPY,OAAO,CAAPA;AACAA,EAAAA,OAAO,CAAPA,GAAAA,GAAAA,aAAAA,CAAAA,EAAAA,EAAkBZ,SAAS,CAATA,OAAAA,CAAlBY,GAAAA,EAAAA,EAAAA,EAA4CA,OAAO,CAAnDA,GAAAA,CAAAA;;AAEA,MAAMI,MAAM,GAAA,aAAA,CAAA;AACVC,IAAAA,MAAM,EAAEC,SAAS,CAAA,OAAA,EADP,OACO,CADP;AAEVC,IAAAA,aAAa,EAAE;AAFL,GAAA,EAGPP,OAAO,CAHA,GAAA,EAAA;AAIVQ,IAAAA,QAAQ,EAJE,KAAA;AAKVC,IAAAA,KAAK,EAAE,SAAA,KAAA,CAAA,CAAA,EAAK;AACV,YAAM,IAAA,KAAA,CAAN,CAAM,CAAN;AACD;AAPS,GAAA,CAAZ;;AAUA,MAAMC,MAAM,GAAGC,IAAI,CAAJA,KAAAA,CAAAA,OAAAA,EAAf,MAAeA,CAAf;AACA,SAAOD,MAAM,CAAb,IAAA;AACD;;AAGD,SAAA,iBAAA,CAAA,aAAA,EAAA,OAAA,EAAmD;AAEjDV,EAAAA,OAAO,GAAA,aAAA,CAAA,EAAA,EAAOZ,SAAS,CAAhB,OAAA,EAAA,EAAA,EAAPY,OAAO,CAAPA;AACAA,EAAAA,OAAO,CAAPA,GAAAA,GAAAA,aAAAA,CAAAA,EAAAA,EAAkBZ,SAAS,CAATA,OAAAA,CAAlBY,GAAAA,EAAAA,EAAAA,EAA4CA,OAAO,CAAnDA,GAAAA,CAAAA;AAHiD,MAK1CG,SAL0C,GAK7BH,OAAO,CALsB,GAK7BA,CAL6B,SAAA;AAMjD,MAAMY,cAAc,GAAGZ,OAAO,CAAPA,GAAAA,CAAvB,UAAA;AAEA,MAAMa,UAAU,GAAG,IAAnB,UAAmB,EAAnB;AAEA,MAAIC,UAAU,GAAd,IAAA;AACA,MAAIC,SAAS,GAAb,IAAA;AACA,MAAIC,iBAAiB,GAArB,IAAA;AACA,MAAIC,MAAM,GAAV,IAAA;AAEA,MAAMb,MAAM,GAAG;AACbI,IAAAA,QAAQ,EADK,KAAA;AAEbD,IAAAA,aAAa,EAFA,IAAA;AAGbF,IAAAA,MAAM,EAHO,KAAA;AAYba,IAAAA,IAZa,EAAA,SAAA,IAAA,CAAA,OAAA,EAAA,MAAA,EAYS;AACpB,UAAMC,GAAG,GAAGC,OAAO,CAAnB,IAAA;;AAGA,UAAIN,UAAU,IAAI,CAAlB,SAAA,EAA8B;AAC5B,YAAMT,MAAM,GAAGL,OAAO,CAAPA,MAAAA,KAAAA,SAAAA,GAA+BqB,WAAW,CAA1CrB,GAA0C,CAA1CA,GAAkDA,OAAO,CAAxE,MAAA;;AACA,YAAA,MAAA,EAAY;AACVe,UAAAA,SAAS,GAATA,GAAAA;AACA;AACD;AACF;;AAGD,UAAA,UAAA,EAAgB;AACdD,QAAAA,UAAU,GAAVA,KAAAA;AACAG,QAAAA,MAAM,GAAGK,YAAY,CAAA,GAAA,EAArBL,SAAqB,CAArBA;AACD;;AAGDD,MAAAA,iBAAiB,GACfA,iBAAiB,IAAI,IAAA,iBAAA,CAAA,cAAA,EAAA,MAAA,EADvBA,SACuB,CADvBA;AAGAA,MAAAA,iBAAiB,CAAjBA,MAAAA,CAAAA,GAAAA;;AAEA,UAAIA,iBAAiB,CAArB,MAAIA,EAAJ,EAAgC;AAC9BH,QAAAA,UAAU,CAAVA,OAAAA,CAAmBG,iBAAiB,CAApCH,kBAAmBG,EAAnBH;AACD;AAtCU,KAAA;AA0CbU,IAAAA,QA1Ca,EAAA,SAAA,QAAA,CAAA,OAAA,EAAA,IAAA,EA0CW;AAEtB,UAAMC,KAAK,GAAGR,iBAAiB,CAA/B,kBAAcA,EAAd;;AACA,UAAA,KAAA,EAAW;AACTH,QAAAA,UAAU,CAAVA,OAAAA,CAAAA,KAAAA;AACD;;AACDA,MAAAA,UAAU,CAAVA,KAAAA;AACD;AAjDY,GAAf;AAoDAF,EAAAA,IAAI,CAAJA,KAAAA,CAAAA,aAAAA,EAAAA,MAAAA,EAAAA,qBAAAA;AAIA,SAAA,UAAA;AACD;;AAED,SAAA,WAAA,CAAA,GAAA,EAA0B;AACxB,SAAO,GAAG,CAAH,KAAA,CAAU,UAAA,KAAA,EAAK;AAAA,WAAI,OAAA,KAAA,KAAJ,QAAA;AAAtB,GAAO,CAAP;AACD;;AAED,SAAA,SAAA,CAAA,OAAA,EAAA,OAAA,EAAqC;AACnC,MAAI,YAAJ,OAAA,EAAyB;AACvB,WAAOX,OAAO,CAAd,MAAA;AACD;;AAED,MAAIK,MAAM,GAAV,KAAA;AACAM,EAAAA,IAAI,CAAJA,KAAAA,CAAAA,OAAAA,EAAoB;AAClBH,IAAAA,QAAQ,EADU,KAAA;AAElBD,IAAAA,aAAa,EAFK,IAAA;AAGlBW,IAAAA,IAAI,EAAE,SAAA,IAAA,CAAA,OAAA,EAAA,MAAA,EAAqB;AACzB,UAAMC,GAAG,GAAGC,OAAO,CAAnB,IAAA;AACAf,MAAAA,MAAM,GAAGgB,WAAW,CAApBhB,GAAoB,CAApBA;AACAoB,MAAAA,MAAM,CAANA,KAAAA;AACD;AAPiB,GAApBd;AAUA,SAAA,MAAA;AACD;;AAED,SAAA,YAAA,CAAA,GAAA,EAAA,SAAA,EAAsC;AACpC,MAAMM,MAAM,GAAGF,SAAS,GAAA,EAAA,GAAxB,EAAA;;AACA,OAAK,IAAIW,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGP,GAAG,CAAvB,MAAA,EAAgCO,CAAhC,EAAA,EAAqC;AACnC,QAAMC,UAAU,GAAIZ,SAAS,IAAIA,SAAS,CAAvB,CAAuB,CAAtBA,IAApB,CAAA;AACA,QAAMa,KAAK,GAAGT,GAAG,CAAjB,CAAiB,CAAjB;;AACA,YAAA,OAAA,CAAA,KAAA,CAAA;AACE,WAAA,QAAA;AACA,WAAA,SAAA;AAEEF,QAAAA,MAAM,CAANA,UAAM,CAANA,GAAqB;AAAC3B,UAAAA,IAAI,EAAEuC,MAAM,CAAb,UAAa,CAAb;AAA2BC,UAAAA,KAAK,EAAhC,CAAA;AAAqCC,UAAAA,IAAI,EAAEC;AAA3C,SAArBf;AACA;;AACF,WAAA,QAAA;AACA;AACEA,QAAAA,MAAM,CAANA,UAAM,CAANA,GAAqB;AAAC3B,UAAAA,IAAI,EAAEuC,MAAM,CAAb,UAAa,CAAb;AAA2BC,UAAAA,KAAK,EAAhC,CAAA;AAAqCC,UAAAA,IAAI,EAAEE;AAA3C,SAArBhB;AARJ;AAYD;;AACD,SAAA,MAAA;AACD","sourcesContent":["// __VERSION__ is injected by babel-plugin-version-inline\n/* global __VERSION__ */\n/* global TextDecoder */\nimport {AsyncQueue, TableBatchBuilder, RowTableBatch} from '@loaders.gl/tables';\nimport Papa from './libs/papaparse';\nimport AsyncIteratorStreamer from './lib/async-iterator-streamer';\n\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nconst CSVLoader = {\n  id: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv'],\n  mimeType: 'text/csv',\n  category: 'table',\n  parse: async (arrayBuffer, options) =>\n    parseCSVSync(new TextDecoder().decode(arrayBuffer), options),\n  parseTextSync: parseCSVSync,\n  parseInBatches: parseCSVInBatches,\n  testText: null,\n  options: {\n    csv: {\n      TableBatch: RowTableBatch,\n      batchSize: 10\n    }\n  }\n};\n\nexport default CSVLoader;\n\nfunction parseCSVSync(csvText, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...CSVLoader.options, ...options};\n  options.csv = {...CSVLoader.options.csv, ...options.csv};\n\n  const config = {\n    header: hasHeader(csvText, options),\n    dynamicTyping: true, // Convert numbers and boolean values in rows from strings\n    ...options.csv,\n    download: false, // We handle loading, no need for papaparse to do it for us\n    error: e => {\n      throw new Error(e);\n    }\n  };\n\n  const result = Papa.parse(csvText, config);\n  return result.data;\n}\n\n// TODO - support batch size 0 = no batching/single batch?\nfunction parseCSVInBatches(asyncIterator, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...CSVLoader.options, ...options};\n  options.csv = {...CSVLoader.options.csv, ...options.csv};\n\n  const {batchSize} = options.csv;\n  const TableBatchType = options.csv.TableBatch;\n\n  const asyncQueue = new AsyncQueue();\n\n  let isFirstRow = true;\n  let headerRow = null;\n  let tableBatchBuilder = null;\n  let schema = null;\n\n  const config = {\n    download: false, // We handle loading, no need for papaparse to do it for us\n    dynamicTyping: true, // Convert numbers and boolean values in rows from strings\n    header: false, // Unfortunately, header detection is not automatic and does not infer types\n\n    // chunk(results, parser) {\n    //   // TODO batch before adding to queue.\n    //   console.log('Chunk:', results, parser);\n    //   asyncQueue.enqueue(results.data);\n    // },\n\n    // step is called on every row\n    step(results, parser) {\n      const row = results.data;\n\n      // Check if we need to save a header row\n      if (isFirstRow && !headerRow) {\n        const header = options.header === undefined ? isHeaderRow(row) : options.header;\n        if (header) {\n          headerRow = row;\n          return;\n        }\n      }\n\n      // If first data row, we can deduce the schema\n      if (isFirstRow) {\n        isFirstRow = false;\n        schema = deduceSchema(row, headerRow);\n      }\n\n      // Add the row\n      tableBatchBuilder =\n        tableBatchBuilder || new TableBatchBuilder(TableBatchType, schema, batchSize);\n\n      tableBatchBuilder.addRow(row);\n      // If a batch has been completed, emit it\n      if (tableBatchBuilder.isFull()) {\n        asyncQueue.enqueue(tableBatchBuilder.getNormalizedBatch());\n      }\n    },\n\n    // complete is called when all rows have been read\n    complete(results, file) {\n      // Ensure any final (partial) batch gets emitted\n      const batch = tableBatchBuilder.getNormalizedBatch();\n      if (batch) {\n        asyncQueue.enqueue(batch);\n      }\n      asyncQueue.close();\n    }\n  };\n\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n\n  // TODO - Does it matter if we return asyncIterable or asyncIterator\n  // return asyncQueue[Symbol.asyncIterator]();\n  return asyncQueue;\n}\n\nfunction isHeaderRow(row) {\n  return row.every(value => typeof value === 'string');\n}\n\nfunction hasHeader(csvText, options) {\n  if ('header' in options) {\n    return options.header;\n  }\n\n  let header = false;\n  Papa.parse(csvText, {\n    download: false,\n    dynamicTyping: true,\n    step: (results, parser) => {\n      const row = results.data;\n      header = isHeaderRow(row);\n      parser.abort();\n    }\n  });\n\n  return header;\n}\n\nfunction deduceSchema(row, headerRow) {\n  const schema = headerRow ? {} : [];\n  for (let i = 0; i < row.length; i++) {\n    const columnName = (headerRow && headerRow[i]) || i;\n    const value = row[i];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n  }\n  return schema;\n}\n"]},"metadata":{},"sourceType":"module"}