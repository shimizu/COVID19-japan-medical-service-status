{"ast":null,"code":"export function deduceTableSchema(table) {\n  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var deducedSchema = Array.isArray(table) ? deduceSchemaForRowTable(table) : deduceSchemaForColumnarTable(table);\n  return Object.assign(deducedSchema, schema);\n}\n\nfunction deduceSchemaForColumnarTable(columnarTable) {\n  var schema = {};\n\n  for (var field in columnarTable) {\n    var column = columnarTable[field];\n\n    if (ArrayBuffer.isView(column)) {\n      schema[field] = column.constructor;\n    } else if (column.length) {\n      var value = column[0];\n      schema[field] = deduceTypeFromValue(value);\n    }\n\n    schema[field] = schema[field] || null;\n  }\n\n  return schema;\n}\n\nfunction deduceSchemaForRowTable(rowTable) {\n  var schema = {};\n\n  if (rowTable.length) {\n    var row = rowTable[0];\n\n    for (var field in row) {\n      var value = row[field];\n      schema[field] = deduceTypeFromValue(value);\n    }\n  }\n\n  return schema;\n}\n\nfunction deduceTypeFromValue(value) {\n  if (value instanceof Date) {\n    return Date;\n  } else if (value instanceof Number) {\n    return Float32Array;\n  } else if (typeof value === 'string') {\n    return String;\n  }\n\n  return null;\n}","map":{"version":3,"sources":["../../../../src/lib/table/schema-utils.js"],"names":["schema","deducedSchema","Array","deduceSchemaForRowTable","deduceSchemaForColumnarTable","Object","column","columnarTable","ArrayBuffer","value","deduceTypeFromValue","rowTable","row"],"mappings":"AAEA,OAAO,SAAA,iBAAA,CAAA,KAAA,EAAiD;AAAA,MAAfA,MAAe,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAN,IAAM;AACtD,MAAMC,aAAa,GAAGC,KAAK,CAALA,OAAAA,CAAAA,KAAAA,IAClBC,uBAAuB,CADLD,KACK,CADLA,GAElBE,4BAA4B,CAFhC,KAEgC,CAFhC;AAIA,SAAOC,MAAM,CAANA,MAAAA,CAAAA,aAAAA,EAAP,MAAOA,CAAP;AACD;;AAED,SAAA,4BAAA,CAAA,aAAA,EAAqD;AACnD,MAAML,MAAM,GAAZ,EAAA;;AACA,OAAK,IAAL,KAAA,IAAA,aAAA,EAAmC;AACjC,QAAMM,MAAM,GAAGC,aAAa,CAA5B,KAA4B,CAA5B;;AAEA,QAAIC,WAAW,CAAXA,MAAAA,CAAJ,MAAIA,CAAJ,EAAgC;AAC9BR,MAAAA,MAAM,CAANA,KAAM,CAANA,GAAgBM,MAAM,CAAtBN,WAAAA;AADF,KAAA,MAGO,IAAIM,MAAM,CAAV,MAAA,EAAmB;AACxB,UAAMG,KAAK,GAAGH,MAAM,CAApB,CAAoB,CAApB;AACAN,MAAAA,MAAM,CAANA,KAAM,CAANA,GAAgBU,mBAAmB,CAAnCV,KAAmC,CAAnCA;AAED;;AAEDA,IAAAA,MAAM,CAANA,KAAM,CAANA,GAAgBA,MAAM,CAANA,KAAM,CAANA,IAAhBA,IAAAA;AACD;;AACD,SAAA,MAAA;AACD;;AAED,SAAA,uBAAA,CAAA,QAAA,EAA2C;AACzC,MAAMA,MAAM,GAAZ,EAAA;;AACA,MAAIW,QAAQ,CAAZ,MAAA,EAAqB;AACnB,QAAMC,GAAG,GAAGD,QAAQ,CAApB,CAAoB,CAApB;;AAEA,SAAK,IAAL,KAAA,IAAA,GAAA,EAAyB;AACvB,UAAMF,KAAK,GAAGG,GAAG,CAAjB,KAAiB,CAAjB;AACAZ,MAAAA,MAAM,CAANA,KAAM,CAANA,GAAgBU,mBAAmB,CAAnCV,KAAmC,CAAnCA;AACD;AACF;;AACD,SAAA,MAAA;AACD;;AAED,SAAA,mBAAA,CAAA,KAAA,EAAoC;AAClC,MAAIS,KAAK,YAAT,IAAA,EAA2B;AACzB,WAAA,IAAA;AADF,GAAA,MAEO,IAAIA,KAAK,YAAT,MAAA,EAA6B;AAClC,WAAA,YAAA;AADK,GAAA,MAEA,IAAI,OAAA,KAAA,KAAJ,QAAA,EAA+B;AACpC,WAAA,MAAA;AACD;;AACD,SAAA,IAAA;AACD","sourcesContent":["// SCHEMA SUPPORT - AUTODEDUCTION\n\nexport function deduceTableSchema(table, schema = null) {\n  const deducedSchema = Array.isArray(table)\n    ? deduceSchemaForRowTable(table)\n    : deduceSchemaForColumnarTable(table);\n  // Deduced schema will fill in missing info from partial options.schema, if provided\n  return Object.assign(deducedSchema, schema);\n}\n\nfunction deduceSchemaForColumnarTable(columnarTable) {\n  const schema = {};\n  for (const field in columnarTable) {\n    const column = columnarTable[field];\n    // Check if column is typed, if so we are done\n    if (ArrayBuffer.isView(column)) {\n      schema[field] = column.constructor;\n      // else we need data\n    } else if (column.length) {\n      const value = column[0];\n      schema[field] = deduceTypeFromValue(value);\n      // TODO - support nested schemas?\n    }\n    // else we mark as present but unknow\n    schema[field] = schema[field] || null;\n  }\n  return schema;\n}\n\nfunction deduceSchemaForRowTable(rowTable) {\n  const schema = {};\n  if (rowTable.length) {\n    const row = rowTable[0];\n    // TODO - Could look at additional rows if nulls in first row\n    for (const field in row) {\n      const value = row[field];\n      schema[field] = deduceTypeFromValue(value);\n    }\n  }\n  return schema;\n}\n\nfunction deduceTypeFromValue(value) {\n  if (value instanceof Date) {\n    return Date;\n  } else if (value instanceof Number) {\n    return Float32Array;\n  } else if (typeof value === 'string') {\n    return String;\n  }\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}