{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport JSZip from 'jszip';\nvar VERSION = typeof \"2.1.6\" !== 'undefined' ? \"2.1.6\" : 'latest';\nexport var ZipLoader = {\n  id: 'zip',\n  name: 'Zip Archive',\n  version: VERSION,\n  extensions: ['zip'],\n  mimeType: 'application/zip',\n  category: 'archive',\n  test: 'PK',\n  parse: parseZipAsync\n};\n\nfunction parseZipAsync(_x, _x2) {\n  return _parseZipAsync.apply(this, arguments);\n}\n\nfunction _parseZipAsync() {\n  _parseZipAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(data, options) {\n    var promises, fileMap, jsZip, zip;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            promises = [];\n            fileMap = {};\n            _context.prev = 2;\n            jsZip = new JSZip();\n            _context.next = 6;\n            return jsZip.loadAsync(data, options);\n\n          case 6:\n            zip = _context.sent;\n            zip.forEach(function (relativePath, zipEntry) {\n              var subFilename = zipEntry.name;\n              var promise = loadZipEntry(jsZip, subFilename, options).then(function (arrayBufferOrError) {\n                fileMap[relativePath] = arrayBufferOrError;\n              });\n              promises.push(promise);\n            });\n            _context.next = 10;\n            return Promise.all(promises);\n\n          case 10:\n            return _context.abrupt(\"return\", fileMap);\n\n          case 13:\n            _context.prev = 13;\n            _context.t0 = _context[\"catch\"](2);\n            options.log.error(\"Unable to read zip archive: \".concat(_context.t0));\n            throw _context.t0;\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[2, 13]]);\n  }));\n  return _parseZipAsync.apply(this, arguments);\n}\n\nfunction loadZipEntry(_x3, _x4, _x5) {\n  return _loadZipEntry.apply(this, arguments);\n}\n\nfunction _loadZipEntry() {\n  _loadZipEntry = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(jsZip, subFilename, options) {\n    var arrayBuffer;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return jsZip.file(subFilename).async(options.dataType || 'arraybuffer');\n\n          case 3:\n            arrayBuffer = _context2.sent;\n            return _context2.abrupt(\"return\", arrayBuffer);\n\n          case 7:\n            _context2.prev = 7;\n            _context2.t0 = _context2[\"catch\"](0);\n            options.log.error(\"Unable to read \".concat(subFilename, \" from zip archive: \").concat(_context2.t0));\n            return _context2.abrupt(\"return\", _context2.t0);\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 7]]);\n  }));\n  return _loadZipEntry.apply(this, arguments);\n}","map":{"version":3,"sources":["../../src/zip-loader.js"],"names":["VERSION","ZipLoader","id","name","version","extensions","mimeType","category","test","parse","parseZipAsync","promises","fileMap","jsZip","zip","subFilename","zipEntry","promise","Promise","options","loadZipEntry","arrayBuffer"],"mappings":"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","sourcesContent":["// __VERSION__ is injected by babel-plugin-version-inline\n/* global __VERSION__ */\nimport JSZip from 'jszip';\n\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport const ZipLoader = {\n  id: 'zip',\n  name: 'Zip Archive',\n  version: VERSION,\n  extensions: ['zip'],\n  mimeType: 'application/zip',\n  category: 'archive',\n  test: 'PK',\n  parse: parseZipAsync\n};\n\n// TODO - Could return a map of promises, perhaps as an option...\nasync function parseZipAsync(data, options) {\n  const promises = [];\n  const fileMap = {};\n\n  try {\n    const jsZip = new JSZip();\n\n    const zip = await jsZip.loadAsync(data, options);\n\n    // start to load each file in this zip\n    zip.forEach((relativePath, zipEntry) => {\n      const subFilename = zipEntry.name;\n\n      const promise = loadZipEntry(jsZip, subFilename, options).then(arrayBufferOrError => {\n        fileMap[relativePath] = arrayBufferOrError;\n      });\n\n      // Ensure Promise.all doesn't ignore rejected promises.\n      promises.push(promise);\n    });\n\n    await Promise.all(promises);\n    return fileMap;\n  } catch (error) {\n    options.log.error(`Unable to read zip archive: ${error}`);\n    throw error;\n  }\n}\n\nasync function loadZipEntry(jsZip, subFilename, options) {\n  // jszip supports both arraybuffer and text, the main loaders.gl types\n  // https://stuk.github.io/jszip/documentation/api_zipobject/async.html\n  try {\n    const arrayBuffer = await jsZip.file(subFilename).async(options.dataType || 'arraybuffer');\n    return arrayBuffer;\n  } catch (error) {\n    options.log.error(`Unable to read ${subFilename} from zip archive: ${error}`);\n    // Store error in place of data in map\n    return error;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}